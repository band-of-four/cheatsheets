
# 1. Понятие тестирования ПО. Основные определения. 

__Тестирование программного обеспечения__ - проверка соответствия между реальным и ожидаемым поведением программы, осуществляемая на конечном наборе тестов, выбранном определенным образом. [IEEE Guide to Software Engineering Body of Knowledge, SWEBOK, 2004] В более широком смысле, тестирование - это одна из техник контроля качества, включающая в себя активности по планированию работ (Test Management), проектированию тестов (Test Design), выполнению тестирования (Test Execution) и анализу полученных результатов (Test Analysis).

__Верификация (Verification)__ - это процесс оценки системы или её компонентов с целью определения удовлетворяют ли результаты текущего этапа разработки условиям, сформированным в начале этого этапа [IEEE]. Т.е. выполняются ли наши цели, сроки, задачи по разработке проекта, определенные в начале текущей фазы.

__Валидация (Validation)__ - это определение соответствия разрабатываемого ПО ожиданиям и потребностям пользователя, требованиям к системе [BS7925-1].

__Mistake__ - ошибка, просчет человека

__Fault__ - дефект, изъян в коде, образовавшийся в результате Mistake

__Failure__ - неисправность, отказ, сбой. внешнее проявление Fault. Когда программа натыкается на Fault и выдает неверный результат

__Error__ - невозможность выполнить задачу вследствие отказа. Отказ может быть вызван внешними силами

__Тестовый случай__ - Input-Processing-Output

__Тестовый сценарий__ - набор тестовых случаев



# 2. Цели и принципы тестирования (ISTQB). 

## Цели:

1. Повышение уверенности в уровне кач-ва

2. Обнаружение дефектов

3. Предотвращение дефектов

4. Предоставление информации для принятия решения

## Приципы:

1. Тестирование демонстрирует наличие дефектов

2. Заблуждение об отсутствии ошибок

3. Тестирование необходимо начинать рано

4. Скопление дефектов (несколько модулей содержат основную массу ошибок)

5. Парадокс пестицида (если одни и те же тесты запускать часто, то они перестают выявлять новые ошибки)

6. Исчерпывающее покрытие недостижимо

7. Тестирование зависит от контекста




# 3. Основная цель тестирования. Уровень доверия, корректное поведение, реальное окружение. 
Увеличение приемлемого уровня пользовательского доверия в том, что программа функционирует корректно во всех необходимых обстоятельствах 

## За уровень доверия отвечают:

1. Наглядность 

2. Уровень остаточного обнаружения дефектов 

  – Число дефектов обнаруженных тестом или набором тестов 

  – Число дефектов обнаруженных в заданное время 
  
  _Пример:«Меньше 10-ти критических дефектов найдено за последние 7 дней»_ 


## Требования к надежности 

  – Сложно показать без испытаний, т. е. работающего ПО

  _Пример: Среднее время между отказами не должно быть меньше 5000 часов_


## Корректное поведение :

  – Определяется из требований, спецификаций, описаний, … 

  – Зависит от уровня тестирования

## Реальное окружение(задает необходимые обстоятельства) требует:
 
1. Реалистичное количество данных - таких же как в целевой системе 

  – В университете 5000 студентов, небольшой рост 

  – Необходим тест на 5000, 6000, 7000 студентов, но не на 100000 

2. Реалистичный набор, комбинация входных данных



# 4. Тестирование и качество. Уровни восприятия тестирования в компании

## Уровень 0 – тестирование == отладка, работка с отладчиком

  - Можно проверить текущую верку программы и проверить есть ли там дефекты или нет, но невозможно сделать это действие повторяемым, например, перед каждым запуском программы.

  – Не отличает некорректное поведение и ошибки в программе

  – Не учитывает требования надежности и безопасности

  - Невозможно сформулировать является ли такое поведение корректным или нет

## Уровень 1 - предназначение – показать корректность ПО. Пишутся тесты, проверяется, что они ВСЕ выполняются, значит дефектов нет (слишком упрощенное восприятие действительности)

  – Невозможно доказать

  – Что значит “ошибок нет”?
  
  – Нет формальных правил

## Уровень 2 - Демонстрация ошибок

  Конфликт разработчиков и тестировщиков

## Уровень 3 - Тестирование может показать наличие ошибок

  – Используя ПО мы подвержены рискам
  
  – Риск – последствия незначительные
  
  – Риск – последствия катастрофические

  –Тестировщики и разработчики совместно снижают риски

## Уровень 4 — Тестирование - это возможный способ оценки качества программного обеспечения в терминах найденных дефектов

  – Функциональное

  – Нефункциональное :надежность, практичность, эффективность, сопровождаемость и переносимость


# 5. Участники тестирования, их роль, квалификация и обязанности

__Деятельность и роли в тестировании__ 

● Проектирование тестов 

– На основании формальных критериев 

– На основании знаний предметной области, опыта и экспертизы 

● Автоматизация тестов 

– Знание средств, скриптов 

● Исполнение тестов 

– Нет специальных требований к квалификации 

● Анализ результатов 

– Знания предметной области

__Роли:__

_Test manager_ - определение объемов тестирования, стратегии, расписания

_Test designer_ - анализ системы, определение тестовых случаев, обзор тестового покрытия

_Test engineer_ - вся грязная работа. Создание тестов, прогон тестов, заполнение отчетов об ошибках




# 6. Мониторинг прогресса и контроль тестирования (ISTQB) 

__Целью мониторинга тестирования__ является предоставление результата и обзора процесса тестирования. Информация отслеживается вручную или автоматически и может быть использована для измерения критериев выхода, таких как покрытие. Метрики также могут быть использованы для оценки прогресса тестирования по сравнению с запланированным расписанием и бюджетом.

__Контроль тестирования__ описывает любые направляющие или корректирующие действия, принятые как результат по полученной и собранной информации и значениям метрик. Контроль тестирования может затрагивать любые действия по тестированию, а также воздействовать на другие действия и задачи жизненного цикла ПО.


# 7. Модульное тестирование. Понятие модуля. Драйверы и заглушки. 

## Модульное тестирование

__Модульное тестирование__ - процесс в программировании, позволяющий проверить модули исходного кода программы

__Цель модульного тестирования__ — изолировать отдельные части программы и показать их работоспособность.

В ходе модульного тестирования решаются задачи:

- Поощрение изменений - позволяет программистам проводить рефакторинг, будучи уверенными, что модуль по-прежнему работает корректно

- Упрощение интеграции - странить сомнения по поводу отдельных модулей и может быть использовано для подхода к тестированию «снизу вверх»

- Документирование кода - тесты можно рассматривать как «живой документ»

- Отделение интерфейса от реализации -

## Понятие модуля

__Модуль программы_ - компонент минимального размера, который может быть независимо протестирован в ходе верификации программной системы

Модуль может быть одним из:

- модуль – это часть программного кода, выполняющая одну функцию с точки зрения функциональных требований;

- модуль – это программный модуль, т.е. минимальный компилируемый элемент программной системы;

- модуль – это задача в списке задач проекта (с точки зрения его менеджера);

- модуль – это один класс или их множество с единым интерфейсом.

## Заглушка

__Заглушка__ – часть программы, которая симулирует обмен данными с тестируемым компонентом, выполняет имитацию рабочей системы. 

● Эмулирует поведение подчиненной программы 

– Подпрограмма, функция, процедура 

– Аппаратное прерывание, передача данных 

● Интерфейс совпадает, внутренность нет 

– Предопределенные ответы для заданных аргументов, исключения

– Постоянная генерация прерываний

● Используются вместо реальной программы 

– Компилируется и линкуется 

● Простая 

– Нельзя тестировать заглушку! 

● Обычно 1 строка кода 

● Возможна дополнительная логика 

– 50 раз возвращать 42, на 51 — IndexOutOfBounds 

● Может читать значения из текстового файла 

● Возможна настройка драйвером перед выполнением 


## Драйверы 

__Драйвер__ – определенный модуль теста, который выполняют тестируемый нами элемент.

● Эмулирует вызываемый компонент 

● Обычно уже более сложная программа 

  – Устанавливает окружение 
  
  – Подготавливает входные данные 

● Дополнительно может: 

  – Запускать серию тестов 

  – Настраивать заглушки 

  – Формировать журнал результатов



## 8. V-образная модель. Статическое и динамическое тестирование.

<img src="https://sun9-11.userapi.com/impf/GoO6L5cOx0O9ihQzVY5kIGN9B_00N8r8WQF2YQ/fh-82IE2QG4.jpg?size=1031x624&quality=96&proxy=1&sign=369fbf137f1fb4beb882763d052352c8&type=album">

__Статическое тестирование (рецензирование)__

– Не включает выполнения кода

– Ручное, автоматизированное

– Неформальное, сквозной контроль, инспекция

__Динамическое__

– Запуск модулей, групп модулей, всей системы

– После появления первого кода (а иногда перед!)

# 9. Валидация и верификация. Тестирование методом "чёрного" и "белого" ящика. 

## Валидация

– Проверка на соответствие ожиданиями

– ПО выполняет требования пользователя?

– Пирожок (мясной, вегетарианский, сладкий)

– Have we done the right thing?

## Верификация

– Внутреннее управление качеством

– ПО выполняет требования спецификации?

– Пирожок (размер, степень прожарки, начинка, …)

– Have we done the thing right?

## Тестирование методом "чёрного" и "белого" ящика__

__Тестирование методом белого ящика__ - разработчик теста имеет доступ к исходному коду программ

__Тестирование матодом черного ящика__ - При тестировании чёрного ящика тестировщик имеет доступ к программе только через те же интерфейсы, что и заказчик или пользователь, либо через внешние интерфейсы, позволяющие другому компьютеру либо другому процессу подключиться к системе для тестирования.



# 10. Тестовый случай, тестовый сценарий и тестовое покрытие. 

__Тестовый случай__ - это артефакт, который описывает набор входных значений, ожидаемых, фактических результатов и направлен на проверку некоторой функциональности тестируемого приложения

__Тестовый сценарий__ - это высокоуровневая классификация требований теста, сгруппированных в зависимости от функциональности модуля. Один сценарий может иметь несколько тестовых случаев.

__тестовое покрытие__ - одна из метрик оценки качества тестирования, представляющая из себя плотность покрытия тестами требований либо исполняемого кода.


# 11. Полное тестовое покрытие. Оценка объема и времени полного покрытия. 

Полное тестовое покрытие недостижимо, поэтому тестовое покрытие выбирается с помощью определённых методик: разбиение на классы эквивалентности, использование таблиц переходов, использование таблиц решений.

Необходимо балансировать между количеством тестов, стоимостью и скоростью разработки. Чем больше тестов - тем меньше дефектов, но зависимость не линейная (с каждым новым тесто обнаруживается всё меньше ошибок). Но возрастает стоимость и время разработки



# 12. Повторяемость тестового сценария. Автоматизированное тестирование. Регрессионное тестирование. 

## Повторяемость тестового сценария.

???

## Автоматизированное тестирование. 

Автоматизация тестов 

● Регрессионное тестирование 

● Повторение тестового сценария 

● Приемочное тестирование 

● Сокращение ручного труда

● Проверка одного приложения в разных окружениях

## Регрессионное тестирование.


__Регрессионное тестирование__ — собирательное название для всех видов тестирования программного обеспечения, направленных на обнаружение ошибок в уже протестированных участках исходного кода.

Направления:

- Автоматизация регрессионных тестов

- Регрессия багов (поиск проблем, которые официально «были устранены», но есть основания полагать, что они до сих пор существуют.)

- Регрессия старых ошибок (ситуации, когда недавнее изменение кода в одной части приложения сделало нерабочим некоторые или все другие части разрабатываемой 
программы)

Задачи регрессионного тестирования:

- Проверка и утверждение исправления ошибки;

- Тестирование последствия исправлений, так как внесенные исправления могут привнести ошибку

- Гарантировать функциональную преемственность и совместимость

- Уменьшение стоимости и сокращение времени выполнения тестов

# 13. Цели и задачи интеграционного тестирования. Алгоритм интеграционного тестирования. Стратегии интеграции. 

## Интеграционное тестирование 

__Интеграционное тестирование__ – вид тестирования, при котором на соответствие требований проверяется интеграция модулей, их взаимодействие между собой, а также интеграция подсистем в одну общую систему.

● Проверяет интерфейсы и взаимодействие модулей (компонент) или систем
 
– Вызовы API, сообщения между ОО компонентами 

– Баз Данных, пользовательский графический интерфейс 

– Интерфейсы взаимодействия (сетевые, аппаратные, локальные, …. ) 

– Инфраструктурные 

● Может проводиться когда два компонента разработаны  (спроектированы) 

– Остальные добавляются по готовности

# Стратегии интеграции 

● Больше объем интеграции — больше сложность 

– Для каждого интерфейса должен быть разработан короткий тест план

● Выбор в зависимости от архитектуры ПО 

● Последовательность имеет значение 

● Можно тестировать нефункциональные характеристики

## Алгоритмы интеграционного тестирования

### Сверху вниз

Интеграционное тестирование __сверху вниз__ (как в лабе) - сначала тестируют только самый верхний управляющий уровень системы, без модулей более низкого уровня. Затем постепенно с более высокоуровневыми модулями интегрируются более низкоуровневые.

__Преимущества:__

- Легко обнаружить неисправности или ошибки в работе системы.
- В первую очередь проверяются важные модули, а лишь потом модули нижнего порядка.
- По сравнению с другими подходами, время на тестирование интеграции очень коротко.

__Недостатки:__

- Если в модули нижнего уровня заложена важная логика, она не может быть протестирована в первую очередь
- Использование «заглушек»становится обязательным на всех последующих проектах.

### Снизу вверх

Интеграционное тестирование __снизу вверх__ (если бы мы сначала в лабе протестировали синус и ln, потом sin, cos, lnб потом все тригонометрические и логарифмические функции и т.д) - подход подразумевает проверку низкоуровневых систем для начала: вместе и по отдельности. Другими словами процесс тестирования начинается с внутреннего уровня и постепенно доходит до наиболее критичных позиций.

__Преимущества:__

- Если определенный модуль перестает функционировать, его ошибка может быть сразу же исправлена.
- Требуется минимальное время на идентификацию и устранение ошибок.

__Недостатки:__

- Общее время проверки всех модулей довольно долгое
- Если ПО содержит много небольших модулей мелкого уровня, которые очень сложны в своей имплементации, то для завершения процесса тестирования может потребоваться больше времени.

### Большой взрыв

Тестирование методом __большого взрыва__ -  созданные и запрограммированные модули и системные компоненты соединены между собой. При объединении эти модули тестируются как единое целое. После проведения юнит-тестов, модули также проверяются вместе, еще до образования целостной программной системы.

__Преимущества:__

- Удобен  при тестировании небольших систем.
- Быстрое нахождение ошибок

__Недостатки:__

- Так как модули завязаны на одной системе, порой очень трудно найти источник дефектов.
- Если в системе используется много модулей, может уйти достаточно времени, чтобы пересмотреть все реализованные функциональности.




# 14. Тестирование системы целиком  - системное тестирование

Системное тестирование программного обеспечения — это тестирование ПО, выполняемое на полной, интегрированной системе, с целью проверки соответствия системы исходным требованиям. Системное тестирование относится к методам тестирования чёрного ящика, и, тем самым, не требует знаний о внутреннем устройстве системы.

Задача: проверка как функциональных и не функциональных требований в системе в целом. 

При этом выявляются дефекты, такие как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т.д. Для минимизации рисков, связанных с особенностями поведения системы в той или иной среде, во время тестирования рекомендуется использовать окружение максимально приближенное к тому, на которое будет установлен продукт после выдачи.

- на базе требований (requirements based)
- на базе случаев использования (use case based)

Включает несколько фаз:

- Системное тестирование — выполняется внутри организации-разработчика
- Альфа- и Бета-тестирование — выполняется пользователем под контролем разработчика
- Приемочное тестирование — выполняется пользователем.

# 15. Тестирование возможностей, стабильности, отказоустойчивости, совместимости

Относится к нефункциональному тестированию.

__Тестирование возможностей__ - минимальная нагрузка, состоящая из корректных и реальных данных, проверка возможностей и функционала системы.

__Тестирование стабильности__ - добавляем нагрузку, данные всё еще корректны. Проверяем как система работает в более-менее реальных условиях

__Тестирование отказоустойчивости__ - пытаемся всё сломать к чертям. Некорректные данные, большая нагрузка, сбои питания, восстановление после отказа и т.д.

__Тестирование совместимости__ - запуск с различными версиями библиотек, на различном окружении. Смотрим как система со всем этим работает.

# 16. Тестирование производительности - CARAT.

CARAT -- подход к нагрузочному тестированию.

_Capacity_ — Нефункциональные возможности (Максимальное количество (пользователей,
записей в БД, файлов, Кб, ГГц), поддерживаемое системой одновременно, не нарушая других
требований производительности
)

_Accuracy_ — Точность -- корректность алгоритмов и результатов.

_Responce Time_ — Время ответа -- время ответа сервиса при разных видах нагрузки.

_Availability_ — Готовность -- способность сервиса обслуживать клиента.

_Throughput_ — Пропускная способность -- количество операций в секунду, которое может поддерживать система.

# 17. Альфа и Бета тестирование. Приемочное тестирование

__Альфа-тестирование__ — имитация реальной работы с системой штатными разработчиками, либо реальная работа с системой потенциальными пользователями/заказчиком.

Альфа-тестирование - проводится небольшим количеством пользователей внутри организации, разработавшей ПО.

– Может проводиться до окончания системного тестирования
– Ранние отзывы пользователей об использовании системы в рабочем окружении

__Бета-тестирование__ — в некоторых случаях выполняется распространение предварительной версии (в случае проприетарного программного обеспечения иногда с ограничениями по функциональности или времени работы) для некоторой большей группы лиц с тем, чтобы убедиться, что продукт содержит достаточно мало ошибок. Иногда бета-тестирование выполняется для того, чтобы получить обратную связь о продукте от его будущих пользователей.

- Могут быть ошибки
- Может быть не реализован весь функционал
- Ранние отзывы для разработчиков
- Превью для пользователей


__Приёмочное тестирование__ - формальный процесс тестирования, который проверяет соответствие системы требованиям и проводится с целью: определения удовлетворяет ли система приемочным критериям; вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.





# 18. Статическое тестирование. Рецензия, технический анализ, сквозной контроль. 

__Рецензирование__ - вид тестирования ПО (включая код), который может проводиться перед динамическим тестированием. Рецензирование может проводиться вручную или с помощью специальных программных средств. 

Преимущества рецензирования: раннее обнаружение и исправление дефектов, улучшение продуктивности разработки, уменьшение времени разработки, уменьшение времени и стоимости тестирования, сокращение стоимости жизненного цикла, уменьшение числа дефектов и улучшение коммуникаций. Во время рецензирования могут быть найдены упущения, например, в требованиях, которые маловероятно найти во время динамического тестирования.

Основная __идея__ рецензирования заключается в систематической (пере)проверке кода с целью найти ошибки, допущенные при его написании.

__Типы рецензирования:__

- Неформальное рецензирование

  - Главные цели: результат при минимуме затрат

  - Отсутствие формального процесса
  
  - Может принимать форму парного программирования или рецензирования дизайна или кода техническим руководителем

  - Результаты могут быть документированы
  
  - Эффективность зависит от экспертов

- Сквозной контроль

  - Главные цели: обучение, достижение понимания, поиск дефектов

  - Может быть в форме сценариев, сухих прогонов, участия членов команды

  - Не ограниченные по времени сессии

  - Наличие секретаря (не автора) необязательно

  - На практике могут варьироваться от неформальных до строго формальных


- Технический анализ 
  
  - Главные цели: обсуждение, принятие решений, оценка альтернатив, нахождение дефектов, решение технических проблем и проверка соответствия требованиям, планам, нормам и стандартам

  - Документированный процесс определения и нахождения дефектов, который включает участников команды, технических экспертов и, возможно, руководство

  - Может проводиться как равноправный анализ без участия руководства
  
  - В идеале проводится обученным модератором (не автором)

  - Предварительная подготовка экспертов
  
  
  
  
  
  
# 19. Статическое тестирование. Инспекции. 

- Главная цель: поиск дефектов

- Проводится обученным модератором

- Обычно сопровождается равноправным исследованием

- Роли определены

- Включает сбор метрик

- Формальный процесс основан на правилах и контрольных списках

- Определены критерии входы и выхода для приемки программного продукта

- Предварительная подготовка перед встречей

- Инспекционный отчет включает список найденных проблем и вопросов

- Формальный процесс отслеживания o Необязательно - процесс улучшения компонентов




# 20. Статическое тестирование. Статический анализ кода.

Цель статического тестирования - нахождение дефектов в коде или моделях ПО. Фактически статический анализ – это исследование ПО с помощью специального инструмента без его запуска, при динамическом тестировании ПО требуется запуск кода. Статический анализ выявляет дефекты, которые сложно найти при динамическом тестировании. 

Преимущества статического анализа:

- Раннее обнаружение дефектов до исполнения тестов

- Раннее предупреждение о подозрительных аспектах в коде или дизайне с помощью вычисления метрик, таких как коэффициент сложности

- Определение дефектов, которые сложно обнаружить с помощью динамического тестирования

- Определение зависимостей и нарушений целостности в моделях ПО, например ссылок

- Улучшение пригодности к сопровождению кода и дизайна

- Предотвращение дефектов путем усвоения уроков, полученных во время разработки




# 21. Выбор тестового покрытия с помощью анализа эквивалентности. Анализ граничных значений. 

__Класс эквивалентности__ - одно или несколько значений ввода, к которым программное обеспечение применяет одинаковую логику.

__Техника анализа эквивалентности__ - техника, при которой разделяется функционал на группы эквивалентных по своему влиянию на систему значений.

<img src='https://sun9-73.userapi.com/yG1XOnNoXG0j4n4TuVEDp-vA_w4bb3u3enJZ2Q/pjm3ENXpsvs.jpg'>






# 22. Выбор тестового покрытия с помощью таблицы решений. 

__Таблица решений__ — способ компактного представления модели со сложной логикой;

В таблицах решений представлен набор условий, одновременное выполнение которых должно привести к определённому действию.

<img src='https://sun9-29.userapi.com/X2Mj1dIxmUAA4Jd8o_Oi3el8P4APe_fdFH8pEQ/qaW7NTQ-wIg.jpg'>






# 23. Выбор тестового покрытия с помощью диаграммы состояний и таблицы переходов. 

__Диаграма состояний__ – метод тестирования «черного ящика», который используется там, где аспект системы может быть описан конечным автоматом.

<img src="https://sun1-19.userapi.com/q_AY9KRMqamTX5p2TzxZOTqtMBEod8nW35JMWQ/CsDYIP6psuI.jpg">


__Таблица переходов:__

<img src="https://sun9-57.userapi.com/impf/p-jf7feegMsAbr2Gd0x6X-2r1ylmD4yLsdEWng/JWT2Q-z68AA.jpg?size=1121x341&quality=96&proxy=1&sign=f2e9f1344cd39281abb5c87fd829b3f5&type=album">



# 24. Выбор тестового покрытия с помощью функционального тестирования. 

<img src="https://sun9-44.userapi.com/impf/xbAytM9ccSnR3dAdR00wtMJYfPCbbETt4gWQhQ/eULY0YsjyDM.jpg?size=974x594&quality=96&proxy=1&sign=f8ae11866fa78fa5d6233ea126d29f36&type=album">



# 25. Библиотека JUnit. Класс junit.framework.Assert. 

В JUnit существует класс Assert, позволяющий использовать методы для сравнения результата теста с ожидаемым значением.


## Основные функции


`assertEquals` -- использует метод `equals()`

`assertFalse`

`assertNotNull`

`assertNull`

`assertNotSame`

`assertSame` -- cравнивает объекты при помощи  `==` 

`assertTrue`


assertEquals не существует для примитивных типов, потому следует следить за тем, чтобы не произошло автобоксинга(например, результат теста int сравнивается с результатом метода sum, который является long)




# 26. Библиотека JUnit. Основные аннотации для исполнения тестов. 

### Основние аннотации

`@Test`

`@BeforeEach`

`@AfterEach`

`@BeforeAll`

`@AfterAll`

`@Disabled`


# 27. Библиотека JUnit. Дополнительные возможности, запуск с параметрами. 

`@RunWith`  - как запускается тест, класс, указанный в аннотации должен наследоваться от Runner

`@RunWith(Parameterized.class)` -параметризованные тесты

`@Parameters` можно вводить значения данных непосредственно в поля без необходимости использования конструктора

Пример:

```java

@RunWith(Parameterized.class)
public class ParameterizeTest {
    private int valueA;
    private int valueB;
    private int expected;
 
    public ParameterizeTest(int valueA, int valueB, int expected) {
        this.valueA = valueA;
        this.valueB = valueB;
        this.expected = expected;
    }
 
    @Parameterized.Parameters(name = "{index}:sumOf({0}+{1})={2}")
    public static Iterable<Object[]> dataForTest() {
        return Arrays.asList(new Object[][]{
                {1, 1, 2},
                {2, 6, 8},
                {18, 2, 20},
                {13, 15, 28},
                {1, 5, 6}
        });
    }
 
    @Test
    public void paramTest() {
        assertEquals(expected, new Calculator().getSum(valueA,valueB));
    }
}

```




# 28. Анализ эквивалентности с использованием JUnit. 



# 29. Тестирование алгоритмов с использованием JUnit. 



# 30. Модульное тестирование доменной модели с использованием JUnit. 


# 31. Система Selenium. Архитектура, основные команды написания сценариев. 

Selenium - система автоматического управления браузерами.

Включает в себя:

- Selenium WebDriver - библиотека управления браузерами

- Selenium RC - предыдущее поколение библиотеки управления браузерами

- Selenium Server - сервер, позволяющий управлять браузером с удалённой машины

- Selenium Grid - кластер из нескольких Selenium Server. Позволяет параллельно запускать несколько браузеров на разных машинах.

- Selenium IDE - плагин к FireFox для накликивания и написания сценариев.



### Принципы написания сценариев

Selrnium IDE

#### Команды:

- `clic`k или `clickAndWait` — ссылки,
переключатели, radio-кнопки
- `type` — ввод значений
- `select` — выбор значений из списка
- `оpen` — открывает страницу
- `assert***`
- `wait***` - ожидание события
- `verify ***` - проверка

#### Assert vs verify

- Предназначены для проверки содержимого
элемента UI
- Если `verification` неуспешна — тест
продолжается
- Если неуспешна `assertion` — тест
останавливается

#### Синхронизация:

- `waitForPageLoad(timeout`) загрузка страницы
 ошибка по таймауту
- `waitForAlert`
- `waitForTable` — полная загрузка таблицы
- `waitForTitle` — загрузка заголовка
- Другие команды синхронизации

#### Другие:

- `store` — сохранение значений в переменной
- `echo` — запись значения в лог selenium
– Можно использовать `${var}`



# 32. Система Selenium. Assertion & Verification. Команды. 


#### Assert vs verify

- Предназначены для проверки содержимого
элемента UI
- Если `verification` неуспешна — тест
продолжается
- Если неуспешна `assertion` — тест
останавливается


`verifyTextPresent`

Команда verifyTextPresent используется, чтобы проверить наличие определенного текста в любом месте страницы.

`verifyElementPresent`

Эта команда используется, когда необходимо проверить наличие определенного элемента интерфейса, а не его содержимое.

`verifyText`

Команда verifyText, используется когда нужно проверить как текст, так и соответствующий ему элемент интерфейса пользователя.

(про команды можно в прошлом вопросе поcмотреть)







# 33. Система Selenium. Команды wait**. 

См п.31 + 

Команды ожидания (`waitFor`) сообщают Selenium о том, что необходимо дождаться выполнения определенного условия (это полезно для тестирования приложений на Ajax). Если условие выполняется, тест без остановки продолжит работу. А если условие не выполняется, тест будет остановлен до тех пор, пока оно не выполнится. А если условие так и не выполнится в течение установленного тайм-аута, оно будет считаться проваленным

Команды “`AndWait`”
Разница между стандартной командой и ее AndWait разновидностью заключается в том, что после выполнения стандартной команды (например, click) Selenium как можно быстрее перейдет к выполнению следующей команды тестового сценария. Разновидность AndWait (например, clickAndWait) приказывает Selenium дождаться загрузки страницы после выполнения команды.

В веб-приложениях на базе AJAX данные приходят с сервера без обновления страницы. Команды с AndWait не смогут нормально выполняться по этой причине. Приостановка выполнения тестового сценария на определенное время - неверный подход, поскольку веб-элемент может появиться на странице раньше или позже указанного времени, это зависит от скорости отклика системы, нагрузки либо иных не подконтрольных факторов, приводящих к сбоям теста. Лучшим выходом из ситуации является задание динамического периода ожидания появления элемента, а после удачной проверки – продолжение выполнения тестового сценария.

Разновидности команд `waitFor`, такие как `waitForElementPresent` либо `waitForVisible`, позволяют задавать динамическое время ожидания, каждую секунду проверяя указанное условие. После удачной проверки Selenium перейдет к выполнению следующей команды.


# 34. Система Selenium. Selenium RC, WebDriver, Grid. 

#### Selenium RC

работает только с использованием JavaScript для каждой команды. Это означает, что все, что вы пишете, в конечном итоге переводится в Javascript и запускается в браузере.

Плюсы:

- как правило работает одинакого для браузера

Минусы:

- Устарел
- Ограничевается возможностями JS и  same-origin policy (веб-браузер разрешает сценариям, содержащимся на первой веб-странице, получать доступ к данным на второй веб-странице, но только если обе веб-страницы имеют одинаковое происхождение.)

#### WebDriver 

WebDriver фактически использует собственный и родной API каждого браузера для работы с ними

Плюсы:

- Быстрее
- Более гибкий

Минусы:

- может работать по-разному в каждом браузере
- могут возникать ошибки при обновлении браузеров

#### Selenium IDE

Selenium IDE — это инструмент для автоматизации действий веб-браузера. 

Ограничения:

- Слабо развитое управление логикой теста
(циклы, условия, ….)
- Запускает только свои сценарии
- Сложно использовать с динамическим
содержимым

#### Selenium GRID

Selenium Grid позволяет выполнять сценарии WebDriver на удаленных машинах (виртуальных или реальных) путем маршрутизации команд, отправляемых клиентом, в удаленные экземпляры браузера. Его цель - предоставить простой способ запускать тесты параллельно на нескольких машинах.





# 35. Язык XPath. Основные конструкции, оси. 

## Основные конструкции


<table class="table table-striped table-bordered table-hover"><thead><tr><th width="20%">Выражение</th><th width="80%">Результат</th></tr></thead><tbody><tr class="odd"><td><em>имя_узла</em></td><td>Выбирает все узлы с именем "имя_узла"</td></tr><tr class="even"><td>/</td><td>Выбирает от корневого узла</td></tr><tr class="odd"><td>//</td><td>Выбирает узлы от текущего узла, соответствующего выбору, независимо от их местонахождения </td></tr><tr class="even"><td>.</td><td>Выбирает текущий узел</td></tr><tr class="odd"><td>..</td><td>Выбирает родителя текущего узла</td></tr><tr class="even"><td>@</td><td>Выбирает атрибуты</td></tr></tbody></table>

<table class="wikitable sortable jquery-tablesorter">
<thead><tr>
<th data-sort-type="text" class="headerSort" tabindex="0" role="columnheader button" title="Упорядочить по возрастанию">Обозначение
</th>
<th class="unsortable">Описание
</th></tr></thead><tbody>
<tr>
<td><span style="display:none" class="sortkey">02</span><span class="nowrap"><code>*</code></span>
</td>
<td>Обозначает <i>любое</i> имя или набор символов по указанной оси, например: <code>*</code>&nbsp;— любой дочерний узел; <code>@*</code>&nbsp;— любой атрибут
</td></tr>
<tr>
<td><span style="display:none" class="sortkey">01</span><span class="nowrap"><code>$name</code></span>
</td>
<td>Обращение к переменной. <code>name</code>&nbsp;— имя переменной или параметра
</td></tr>
<tr>
<td><span style="display:none" class="sortkey">04</span><span class="nowrap"><code>[]</code></span>
</td>
<td>Дополнительные условия выборки (или предикат шага адресации). Должен содержать логическое значение. Если содержит числовое, считается что это порядковый номер узла, что эквивалентно приписыванию перед этим числом выражения <code>position()=</code>
</td></tr>
<tr>
<td><span style="display:none" class="sortkey">05</span><span class="nowrap"><code>{}</code></span>
</td>
<td>Если применяется внутри тега другого языка (например HTML), то XSLT-процессор рассматривает содержимое фигурных скобок как XPath
</td></tr>
<tr>
<td><span style="display:none" class="sortkey">03</span><span class="nowrap"><code>/</code></span>
</td>
<td>Определяет уровень дерева, т.&nbsp;е. разделяет шаги адресации
</td></tr>
<tr>
<td><span style="display:none" class="sortkey">06</span><span class="nowrap"><code>|</code></span>
</td>
<td>Объединяет результат. Т.&nbsp;е., в рамках одного пути можно написать несколько путей разбора через знак <code>|</code>, и в результат такого выражения войдёт всё, что будет найдено любым из этих путей
</td></tr></tbody><tfoot></tfoot></table>

## Оси


`child::` — содержит множество элементов-потомков (элементов, расположенных на один уровень ниже). Это название сокращается полностью, то есть его можно вовсе опускать.

`descendant::` — содержит полное множество элементов-потомков (то есть, как ближайших элементов-потомков, так и всех их элементов-потомков).

`descendant-or-self::` — содержит полное множество элементов-потомков и текущий элемент. Выражение /descendant-or-self::node()/ можно сокращать до //.

`ancestor::` — содержит множество элементов-предков.

`ancestor-or-self::` — содержит множество элементов-предков и текущий элемент.

`parent::` — содержит элемент-предок на один уровень назад. Это обращение можно заменить на ..

`self::` — содержит текущий элемент. Это обращение можно заменить на .

`following::` — содержит множество элементов, расположенных ниже текущего элемента по дереву (на всех уровнях и слоях), исключая собственных потомков.

`following-sibling::` — содержит множество братских элементов того же уровня, следующих за текущим слоем.

`preceding::` — содержит множество элементов, расположенных выше текущего элемента по дереву (на всех уровнях и слоях), исключая множество собственных предков.

`preceding-sibling::` — содержит множество братских элементов того же уровня, предшествующих текущему слою.

`attribute::` — содержит множество атрибутов текущего элемента. Это обращение можно заменить на символ @

`namespace::` — содержит множество элементов, относящихся к тому или иному пространству имён (то есть присутствует атрибут xmlns).


# 36. Язык XPath. Системные функции. 

<table class="wikitable sortable jquery-tablesorter">
<thead><tr>
<th data-sort-type="text" class="headerSort" tabindex="0" role="columnheader button" title="Упорядочить по возрастанию">Функция
</th>
<th class="unsortable">Описание
</th></tr></thead><tbody>
<tr>
<td data-sort-value="document"><span class="nowrap"><code>node-set <b>document</b>(object, node-set?)</code></span>
</td>
<td>Возвращает документ, указанный в параметре <code>object</code>
</td></tr>
<tr>
<td data-sort-value="format-number"><span class="nowrap"><code>string <b>format-number</b>(number, string, string?)</code></span>
</td>
<td>Форматирует число согласно образцу, указанному во втором параметре. Третий параметр указывает именованный формат числа, который должен быть учтён
</td></tr>
<tr>
<td data-sort-value="generate-id"><span class="nowrap"><code>string <b>generate-id</b>(node-set?)</code></span>
</td>
<td>Возвращает строку, являющуюся уникальным идентификатором
</td></tr>
<tr>
<td data-sort-value="key"><span class="nowrap"><code>node-set <b>key</b>(string, object)</code></span>
</td>
<td>Возвращает множество с указанным ключом (аналогично функции <code>id</code> для идентификаторов)
</td></tr>
<tr>
<td data-sort-value="unparsed-entity-uri"><span class="nowrap"><code>string <b>unparsed-entity-uri</b>(string)</code></span>
</td>
<td>Возвращает непроанализированный URI. Если такового нет, возвращает пустую строку
</td></tr>
<tr>
<td data-sort-value="element-available"><span class="nowrap"><code>boolean <b>element-available</b>(string)</code></span>
</td>
<td>Проверяет, доступен ли элемент или множество, указанное в параметре. Параметр рассматривается как XPath
</td></tr>
<tr>
<td data-sort-value="function-available"><span class="nowrap"><code>boolean <b>function-available</b>(string)</code></span>
</td>
<td>Проверяет, доступна ли функция, указанная в параметре. Параметр рассматривается как XPath
</td></tr>
<tr>
<td data-sort-value="system-property"><span class="nowrap"><code>object <b>system-property</b>(string)</code></span>
</td>
<td>Параметры, возвращающие системные переменные. Могут быть:
<ul><li><code>xsl: version</code>&nbsp;— возвращает версию XSLT процессора.</li>
<li><code>xsl: vendor</code>&nbsp;— возвращает производителя XSLT процессора.</li>
<li><code>xsl: vendor-url</code>&nbsp;— возвращает URL, идентифицирующий производителя.</li></ul>
<p>Если используется неизвестный параметр, функция возвращает пустую строку
</p>
</td></tr>
<tr>
<td data-sort-value="lang"><span class="nowrap"><code>boolean <b>lang</b>(string)</code></span>
</td>
<td>Возвращает <code><b>true</b></code>, если у текущего тега имеется атрибут <code>xml: lang</code>, либо родитель тега имеет атрибут <code>xml: lang</code> и в нём указан совпадающий строке символ
</td></tr></tbody><tfoot></tfoot></table>



# 37. Язык XPath. Функции с множествами. 

## Функции для работы с наборами узлов

<table class="wikitable sortable jquery-tablesorter">
<thead><tr>
<th data-sort-type="text" class="headerSort" tabindex="0" role="columnheader button" title="Упорядочить по возрастанию">Функция
</th>
<th class="unsortable">Описание
</th></tr></thead><tbody>
<tr>
<td data-sort-value="node"><span class="nowrap"><code>node-set <b>node</b>()</code></span>
</td>
<td>Возвращает сам узел. Вместо этой функции часто используют заменитель <code>*</code>, но, в отличие от звёздочки, функция <code>node()</code> возвращает и <i>текстовые</i> узлы
</td></tr>
<tr>
<td data-sort-value="text"><span class="nowrap"><code>string <b>text</b>()</code></span>
</td>
<td>Возвращает узел, если он текстовый
</td></tr>
<tr>
<td data-sort-value="current"><span class="nowrap"><code>node-set <b>current</b>()</code></span>
</td>
<td>Возвращает множество из одного элемента, который является текущим. Если мы делаем обработку множества с предикатами, то единственным способом дотянуться из этого предиката до текущего элемента будет данная функция
</td></tr>
<tr>
<td data-sort-value="position"><span class="nowrap"><code>number <b>position</b>()</code></span>
</td>
<td>Возвращает позицию элемента в множестве элементов оси. Корректно работает только в цикле <code>&lt;xsl:for-each/&gt;</code>
</td></tr>
<tr>
<td data-sort-value="last"><span class="nowrap"><code>number <b>last</b>()</code></span>
</td>
<td>Возвращает номер последнего элемента в множестве элементов оси. Корректно работает только в цикле <code>&lt;xsl:for-each/&gt;</code>
</td></tr>
<tr>
<td data-sort-value="count"><span class="nowrap"><code>number <b>count</b>(node-set)</code></span>
</td>
<td>Возвращает количество элементов в <code>node-set</code>.
</td></tr>
<tr>
<td data-sort-value="name"><span class="nowrap"><code>string <b>name</b>(node-set?)</code></span>
</td>
<td>Возвращает полное имя первого тега в множестве
</td></tr>
<tr>
<td data-sort-value="namespace-url"><span class="nowrap"><code>string <b>namespace-url</b>(node-set?)</code></span>
</td>
<td>Возвращает ссылку на URL, определяющий пространство имён
</td></tr>
<tr>
<td data-sort-value="local-name"><span class="nowrap"><code>string <b>local-name</b>(node-set?)</code></span>
</td>
<td>Возвращает имя первого тега в множестве, без пространства имён
</td></tr>
<tr>
<td data-sort-value="id"><span class="nowrap"><code>node-set <b>id</b>(object)</code></span>
</td>
<td>Находит элемент с уникальным идентификатором
</td></tr></tbody><tfoot></tfoot></table>






# 38. Язык XPath. Строковые, логические и числовые функции. 

## Логические функции

<table class="wikitable sortable jquery-tablesorter">
<thead><tr>
<th data-sort-type="text" class="headerSort" tabindex="0" role="columnheader button" title="Упорядочить по возрастанию">Функция
</th>
<th class="unsortable">Описание
</th></tr></thead><tbody>
<tr>
<td data-sort-value="boolean"><span class="nowrap"><code>boolean <b>boolean</b>(object)</code></span>
</td>
<td>Приводит объект к логическому типу
</td></tr>
<tr>
<td data-sort-value="true"><span class="nowrap"><code>boolean <b>true</b>()</code></span>
</td>
<td>Возвращает истину
</td></tr>
<tr>
<td data-sort-value="false"><span class="nowrap"><code>boolean <b>false</b>()</code></span>
</td>
<td>Возвращает ложь
</td></tr>
<tr>
<td data-sort-value="not"><span class="nowrap"><code>boolean <b>not</b>(boolean)</code></span>
</td>
<td>Отрицание, возвращает истину если аргумент ложь и наоборот
</td></tr></tbody><tfoot></tfoot></table>

### Логические операторы

<table class="wikitable sortable jquery-tablesorter">

<thead><tr>
<th data-sort-type="text" class="headerSort" tabindex="0" role="columnheader button" title="Упорядочить по возрастанию">Символ, оператор
</th>
<th class="unsortable">Значение
</th></tr></thead><tbody>
<tr>
<td><code>or</code></td>
<td>логическое «или»
</td></tr>
<tr>
<td><code>and</code></td>
<td>логическое «и»
</td></tr>
<tr>
<td><code>=</code></td>
<td>логическое «равно»
</td></tr>
<tr>
<td><code>&lt;</code> (&amp;lt;)</td>
<td>логическое «меньше»
</td></tr>
<tr>
<td><code>&gt;</code> (&amp;gt;)</td>
<td>логическое «больше»
</td></tr>
<tr>
<td><code>&lt;=</code> (&amp;lt;=)</td>
<td>логическое «меньше либо равно»
</td></tr>
<tr>
<td><code>&gt;=</code> (&amp;gt;=)</td>
<td>логическое «больше либо равно»
</td></tr></tbody><tfoot></tfoot></table>

## Числовые функции

<table class="wikitable sortable jquery-tablesorter">
<thead><tr>
<th data-sort-type="text" class="headerSort" tabindex="0" role="columnheader button" title="Упорядочить по возрастанию">Функция
</th>
<th class="unsortable">Описание
</th></tr></thead><tbody>
<tr>
<td data-sort-value="number"><span class="nowrap"><code>number <b>number</b>(object?)</code></span>
</td>
<td>Переводит объект в число
</td></tr>
<tr>
<td data-sort-value="sum"><span class="nowrap"><code>number <b>sum</b>(node-set)</code></span>
</td>
<td>Вернёт сумму множества. Каждый тег множества будет преобразован в строку и из него получено число
</td></tr>
<tr>
<td data-sort-value="floor"><span class="nowrap"><code>number <b>floor</b>(number)</code></span>
</td>
<td>Возвращает наибольшее целое число, не большее, чем аргумент (округление к меньшему)
</td></tr>
<tr>
<td data-sort-value="ceiling"><span class="nowrap"><code>number <b>ceiling</b>(number)</code></span>
</td>
<td>Возвращает наименьшее целое число, не меньшее, чем аргумент (округление к большему)
</td></tr>
<tr>
<td data-sort-value="round"><span class="nowrap"><code>number <b>round</b>(number)</code></span>
</td>
<td>Округляет число по математическим правилам
</td></tr></tbody><tfoot></tfoot></table>

### Числовые операторы

<table class="wikitable sortable jquery-tablesorter">

<thead><tr>
<th data-sort-type="text" class="headerSort" tabindex="0" role="columnheader button" title="Упорядочить по возрастанию">Символ, оператор
</th>
<th class="unsortable">Значение
</th></tr></thead><tbody>
<tr>
<td><span style="display:none" class="sortkey">02</span><code>+</code></td>
<td>сложение
</td></tr>
<tr>
<td><span style="display:none" class="sortkey">03</span><code>−</code></td>
<td>вычитание
</td></tr>
<tr>
<td><span style="display:none" class="sortkey">01</span><code>*</code></td>
<td>умножение
</td></tr>
<tr>
<td><code>div</code></td>
<td>обычное деление (<b>не нацело!</b>)
</td></tr>
<tr>
<td><code>mod</code></td>
<td>остаток от деления
</td></tr></tbody><tfoot></tfoot></table>

## Строковые функции

<table class="wikitable sortable jquery-tablesorter">
<thead><tr>
<th data-sort-type="text" class="headerSort" tabindex="0" role="columnheader button" title="Упорядочить по возрастанию">Функция
</th>
<th class="unsortable">Описание
</th></tr></thead><tbody>
<tr>
<td data-sort-value="string"><span class="nowrap"><code>string <b>string</b>(object?)</code></span>
</td>
<td>Возвращает текстовое содержимое элемента. По сути, возвращает объединённое множество <i>текстовых</i> элементов на <i>один</i> уровень ниже
</td></tr>
<tr>
<td data-sort-value="concat"><span class="nowrap"><code>string <b>concat</b>(string, string, string*)</code></span>
</td>
<td>Соединяет строки, указанные в аргументах
</td></tr>
<tr>
<td data-sort-value="string-length"><span class="nowrap"><code>number <b>string-length</b>(string?)</code></span>
</td>
<td>Возвращает длину строки
</td></tr>
<tr>
<td data-sort-value="contains"><span class="nowrap"><code>boolean <b>contains</b>(string, string)</code></span>
</td>
<td>Возвращает <code><b>true</b></code>, если первая строка содержит вторую, иначе — <code><b>false</b></code>
</td></tr>
<tr>
<td data-sort-value="substring"><span class="nowrap"><code>string <b>substring</b>(string, number, number?)</code></span>
</td>
<td>Возвращает строку, вырезанную из строки, начиная с указанного номера, и, если указан второй номер,&nbsp;— количество символов
</td></tr>
<tr>
<td data-sort-value="substring-before"><span class="nowrap"><code>string <b>substring-before</b>(string, string)</code></span>
</td>
<td>Если найдена вторая строка в первой, возвращает строку до первого вхождения второй строки
</td></tr>
<tr>
<td data-sort-value="substring-after"><span class="nowrap"><code>string <b>substring-after</b>(string, string)</code></span>
</td>
<td>Если найдена вторая строка в первой, возвращает строку после первого вхождения второй строки
</td></tr>
<tr>
<td data-sort-value="starts-with"><span class="nowrap"><code>boolean <b>starts-with</b>(string, string)</code></span>
</td>
<td>Возвращает <code><b>true</b></code>, если вторая строка входит в начало первой, иначе — <code><b>false</b></code>
</td></tr>
<tr>
<td data-sort-value="ends-with"><span class="nowrap"><code>boolean <b>ends-with</b>(string, string)</code></span>
</td>
<td>Возвращает <code><b>true</b></code>, если вторая строка входит в конец первой, иначе — <code><b>false</b></code>
</td></tr>
<tr>
<td data-sort-value="normalize-space"><span class="nowrap"><code>string <b>normalize-space</b>(string?)</code></span>
</td>
<td>Убирает лишние и повторные пробелы, а также управляющие символы, заменяя их пробелами
</td></tr>
<tr>
<td data-sort-value="translate"><span class="nowrap"><code>string <b>translate</b>(string, string, string)</code></span>
</td>
<td>Заменяет символы первой строки, которые встречаются во второй строке, на соответствующие позиции символам из второй строки символы из третьей строки. Например, <code>translate("bar", "abc", "ABC")</code> вернёт BAr.
</td></tr></tbody><tfoot></tfoot></table>


# 39. Apache JMeter. Архитектура, Элементы тестового плана. Последовательность выполнения. 

Как эта фигня работает - создает http запросы, эмулируя поведение заданного количества пользователей, посылает их приложению, сохраняет все ответы и анализирует.
Thread Group – Описывает пул пользователей для выполнения теста – Количество, возрастание и пр.. 

Семплеры – Формируют запросы, генерируют результаты – Большой набор встроенных протоколов (TCP, HTTP, FTP, JDBC, SOAP, JMS, SMTP, …..)

Логические контроллеры – Определяют порядок вызова семплеров – Конструкции управления (if, loop, …) – Управление потоком 

Слушатели – Получают ответы – Осуществляют доп. операции с результатами: просмотр, запись, чтение и др. – Не обрабатывают данные! (в командной строке, нужен GUI)

Таймеры – Задержки между запросами – Постоянные, в соответствии с законами 

Аssertion – Проверяют результаты 

Элементы конфигурации – Сохраняют предустановленные значения для семплеров 

Препроцессоры – Изменяют семплеры в их контексте (HTML Link Parser)

Постпроцессоры – Применяются ко всем семплерам в одном контексте

## Порядок выполнения:

1. Конфигурационные элементы
2. Препроцессоры
3. Таймеры
4. Семплеры
5. Постпроцессоры
6. Assertions
7. Слушатели

# 40. Apache Jmeter. Дополнительные возможности. Распределенное тестирование. 

Один компьютер не всегда может эмулировать необходимую в тестовых целях нагрузку, в связи с чем возникает необходимость генерации тестовой нагрузки с нескольких узлов. Для этого необходимо:

1. Запустить JMeter - сервер на всех машинах, которые будут генерировать тестовые запросы

2. Отредактировать файл jmeter.properties на Jmeter клиенте, который будет запускать тесты. В свойстве remote_hosts необходимо перечислить все хосты с Jmeter-серверами

3. Запустить тест на клиенте

