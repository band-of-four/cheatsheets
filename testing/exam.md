
# 1. Понятие тестирования ПО. Основные определения. 

__Тестирование программного обеспечения__ - проверка соответствия между реальным и ожидаемым поведением программы, осуществляемая на конечном наборе тестов, выбранном определенным образом. [IEEE Guide to Software Engineering Body of Knowledge, SWEBOK, 2004] В более широком смысле, тестирование - это одна из техник контроля качества, включающая в себя активности по планированию работ (Test Management), проектированию тестов (Test Design), выполнению тестирования (Test Execution) и анализу полученных результатов (Test Analysis).

__Верификация (Verification)__ - это процесс оценки системы или её компонентов с целью определения удовлетворяют ли результаты текущего этапа разработки условиям, сформированным в начале этого этапа [IEEE]. Т.е. выполняются ли наши цели, сроки, задачи по разработке проекта, определенные в начале текущей фазы.

__Валидация (Validation)__ - это определение соответствия разрабатываемого ПО ожиданиям и потребностям пользователя, требованиям к системе [BS7925-1].

__Mistake__ - ошибка, просчет человека

__Fault__ - дефект, изъян в коде, образовавшийся в результате Mistake

__Failure__ - неисправность, отказ, сбой. внешнее проявление Fault. Когда программа натыкается на Fault и выдает неверный результат

__Error__ - невозможность выполнить задачу вследствие отказа. Отказ может быть вызван внешними силами

__Тестовый случай__ - Input-Processing-Output

__Тестовый сценарий__ - набор тестовых случаев



# 2. Цели и принципы тестирования (ISTQB). 

## Цели:

1. Повышение уверенности в уровне кач-ва

2. Обнаружение дефектов

3. Предотвращение дефектов

4. Предоставление информации для принятия решения

## Приципы:

1. Тестирование демонстрирует наличие дефектов

2. Заблуждение об отсутствии ошибок

3. Тестирование необходимо начинать рано

4. Скопление дефектов (несколько модулей содержат основную массу ошибок)

5. Парадокс пестицида (если одни и те же тесты запускать часто, то они перестают выявлять новые ошибки)

6. Исчерпывающее покрытие недостижимо

7. Тестирование зависит от контекста




# 3. Основная цель тестирования. Уровень доверия, корректное поведение, реальное окружение. 
Увеличение приемлемого уровня пользовательского доверия в том, что программа функционирует корректно во всех необходимых обстоятельствах 

## За уровень доверия отвечают:

1. Наглядность 

2. Уровень остаточного обнаружения дефектов 

  – Число дефектов обнаруженных тестом или набором тестов 

  – Число дефектов обнаруженных в заданное время 
  
  _Пример:«Меньше 10-ти критических дефектов найдено за последние 7 дней»_ 


## Требования к надежности 

  – Сложно показать без испытаний, т. е. работающего ПО

  _Пример: Среднее время между отказами не должно быть меньше 5000 часов_


## Корректное поведение :

  – Определяется из требований, спецификаций, описаний, … 

  – Зависит от уровня тестирования

## Реальное окружение(задает необходимые обстоятельства) требует:
 
1. Реалистичное количество данных - таких же как в целевой системе 

  – В университете 5000 студентов, небольшой рост 

  – Необходим тест на 5000, 6000, 7000 студентов, но не на 100000 

2. Реалистичный набор, комбинация входных данных



# 4. Тестирование и качество. Уровни восприятия тестирования в компании

## Уровень 0 – тестирование == отладка, работка с отладчиком

  - Можно проверить текущую верку программы и проверить есть ли там дефекты или нет, но невозможно сделать это действие повторяемым, например, перед каждым запуском программы.

  – Не отличает некорректное поведение и ошибки в программе

  – Не учитывает требования надежности и безопасности

  - Невозможно сформулировать является ли такое поведение корректным или нет

## Уровень 1 - предназначение – показать корректность ПО. Пишутся тесты, проверяется, что они ВСЕ выполняются, значит дефектов нет (слишком упрощенное восприятие действительности)

  – Невозможно доказать

  – Что значит “ошибок нет”?
  
  – Нет формальных правил

## Уровень 2 - Демонстрация ошибок

  Конфликт разработчиков и тестировщиков

## Уровень 3 - Тестирование может показать наличие ошибок

  – Используя ПО мы подвержены рискам
  
  – Риск – последствия незначительные
  
  – Риск – последствия катастрофические

  –Тестировщики и разработчики совместно снижают риски

## Уровень 4 — Тестирование - это возможный способ оценки качества программного обеспечения в терминах найденных дефектов

  – Функциональное

  – Нефункциональное :надежность, практичность, эффективность, сопровождаемость и переносимость


# 5. Участники тестирования, их роль, квалификация и обязанности

__Деятельность и роли в тестировании__ 

● Проектирование тестов 

– На основании формальных критериев 

– На основании знаний предметной области, опыта и экспертизы 

● Автоматизация тестов 

– Знание средств, скриптов 

● Исполнение тестов 

– Нет специальных требований к квалификации 

● Анализ результатов 

– Знания предметной области

__Роли:__

_Test manager_ - определение объемов тестирования, стратегии, расписания

_Test designer_ - анализ системы, определение тестовых случаев, обзор тестового покрытия

_Test engineer_ - вся грязная работа. Создание тестов, прогон тестов, заполнение отчетов об ошибках




# 6. Мониторинг прогресса и контроль тестирования (ISTQB) 

__Целью мониторинга тестирования__ является предоставление результата и обзора процесса тестирования. Информация отслеживается вручную или автоматически и может быть использована для измерения критериев выхода, таких как покрытие. Метрики также могут быть использованы для оценки прогресса тестирования по сравнению с запланированным расписанием и бюджетом.

__Контроль тестирования__ описывает любые направляющие или корректирующие действия, принятые как результат по полученной и собранной информации и значениям метрик. Контроль тестирования может затрагивать любые действия по тестированию, а также воздействовать на другие действия и задачи жизненного цикла ПО.


# 7. Модульное тестирование. Понятие модуля. Драйверы и заглушки. 

## Модульное тестирование

__Модульное тестирование__ - процесс в программировании, позволяющий проверить модули исходного кода программы

__Цель модульного тестирования__ — изолировать отдельные части программы и показать их работоспособность.

В ходе модульного тестирования решаются задачи:

- Поощрение изменений - позволяет программистам проводить рефакторинг, будучи уверенными, что модуль по-прежнему работает корректно

- Упрощение интеграции - странить сомнения по поводу отдельных модулей и может быть использовано для подхода к тестированию «снизу вверх»

- Документирование кода - тесты можно рассматривать как «живой документ»

- Отделение интерфейса от реализации -

## Понятие модуля

__Модуль программы_ - компонент минимального размера, который может быть независимо протестирован в ходе верификации программной системы

Модуль может быть одним из:

- модуль – это часть программного кода, выполняющая одну функцию с точки зрения функциональных требований;

- модуль – это программный модуль, т.е. минимальный компилируемый элемент программной системы;

- модуль – это задача в списке задач проекта (с точки зрения его менеджера);

- модуль – это один класс или их множество с единым интерфейсом.

## Заглушка

__Заглушка__ – часть программы, которая симулирует обмен данными с тестируемым компонентом, выполняет имитацию рабочей системы. 

● Эмулирует поведение подчиненной программы 

– Подпрограмма, функция, процедура 

– Аппаратное прерывание, передача данных 

● Интерфейс совпадает, внутренность нет 

– Предопределенные ответы для заданных аргументов, исключения

– Постоянная генерация прерываний

● Используются вместо реальной программы 

– Компилируется и линкуется 

● Простая 

– Нельзя тестировать заглушку! 

● Обычно 1 строка кода 

● Возможна дополнительная логика 

– 50 раз возвращать 42, на 51 — IndexOutOfBounds 

● Может читать значения из текстового файла 

● Возможна настройка драйвером перед выполнением 


## Драйверы 

__Драйвер__ – определенный модуль теста, который выполняют тестируемый нами элемент.

● Эмулирует вызываемый компонент 

● Обычно уже более сложная программа 

  – Устанавливает окружение 
  
  – Подготавливает входные данные 

● Дополнительно может: 

  – Запускать серию тестов 

  – Настраивать заглушки 

  – Формировать журнал результатов



## 8. V-образная модель. Статическое и динамическое тестирование.

<img src="https://sun9-11.userapi.com/impf/GoO6L5cOx0O9ihQzVY5kIGN9B_00N8r8WQF2YQ/fh-82IE2QG4.jpg?size=1031x624&quality=96&proxy=1&sign=369fbf137f1fb4beb882763d052352c8&type=album">

__Статическое тестирование (рецензирование)__

– Не включает выполнения кода

– Ручное, автоматизированное

– Неформальное, сквозной контроль, инспекция

__Динамическое__

– Запуск модулей, групп модулей, всей системы

– После появления первого кода (а иногда перед!)

# 9. Валидация и верификация. Тестирование методом "чёрного" и "белого" ящика. 

## Валидация

– Проверка на соответствие ожиданиями

– ПО выполняет требования пользователя?

– Пирожок (мясной, вегетарианский, сладкий)

– Have we done the right thing?

## Верификация

– Внутреннее управление качеством

– ПО выполняет требования спецификации?

– Пирожок (размер, степень прожарки, начинка, …)

– Have we done the thing right?

## Тестирование методом "чёрного" и "белого" ящика__

__Тестирование методом белого ящика__ - разработчик теста имеет доступ к исходному коду программ

__Тестирование матодом черного ящика__ - При тестировании чёрного ящика тестировщик имеет доступ к программе только через те же интерфейсы, что и заказчик или пользователь, либо через внешние интерфейсы, позволяющие другому компьютеру либо другому процессу подключиться к системе для тестирования.



# 10. Тестовый случай, тестовый сценарий и тестовое покрытие. 

__Тестовый случай__ - это артефакт, который описывает набор входных значений, ожидаемых, фактических результатов и направлен на проверку некоторой функциональности тестируемого приложения

__Тестовый сценарий__ - это высокоуровневая классификация требований теста, сгруппированных в зависимости от функциональности модуля. Один сценарий может иметь несколько тестовых случаев.

__тестовое покрытие__ - одна из метрик оценки качества тестирования, представляющая из себя плотность покрытия тестами требований либо исполняемого кода.


# 11. Полное тестовое покрытие. Оценка объема и времени полного покрытия. 

Полное тестовое покрытие недостижимо, поэтому тестовое покрытие выбирается с помощью определённых методик: разбиение на классы эквивалентности, использование таблиц переходов, использование таблиц решений.

Необходимо балансировать между количеством тестов, стоимостью и скоростью разработки. Чем больше тестов - тем меньше дефектов, но зависимость не линейная (с каждым новым тесто обнаруживается всё меньше ошибок). Но возрастает стоимость и время разработки



# 12. Повторяемость тестового сценария. Автоматизированное тестирование. Регрессионное тестирование. 

## Повторяемость тестового сценария.

???

## Автоматизированное тестирование. 

Автоматизация тестов 

● Регрессионное тестирование 

● Повторение тестового сценария 

● Приемочное тестирование 

● Сокращение ручного труда

● Проверка одного приложения в разных окружениях

## Регрессионное тестирование.


__Регрессионное тестирование__ — собирательное название для всех видов тестирования программного обеспечения, направленных на обнаружение ошибок в уже протестированных участках исходного кода.

Направления:

- Автоматизация регрессионных тестов

- Регрессия багов (поиск проблем, которые официально «были устранены», но есть основания полагать, что они до сих пор существуют.)

- Регрессия старых ошибок (ситуации, когда недавнее изменение кода в одной части приложения сделало нерабочим некоторые или все другие части разрабатываемой 
программы)

Задачи регрессионного тестирования:

- Проверка и утверждение исправления ошибки;

- Тестирование последствия исправлений, так как внесенные исправления могут привнести ошибку

- Гарантировать функциональную преемственность и совместимость

- Уменьшение стоимости и сокращение времени выполнения тестов

# 13. Цели и задачи интеграционного тестирования. Алгоритм интеграционного тестирования. Стратегии интеграции. 

## Интеграционное тестирование 

__Интеграционное тестирование__ – вид тестирования, при котором на соответствие требований проверяется интеграция модулей, их взаимодействие между собой, а также интеграция подсистем в одну общую систему.

● Проверяет интерфейсы и взаимодействие модулей (компонент) или систем
 
– Вызовы API, сообщения между ОО компонентами 

– Баз Данных, пользовательский графический интерфейс 

– Интерфейсы взаимодействия (сетевые, аппаратные, локальные, …. ) 

– Инфраструктурные 

● Может проводиться когда два компонента разработаны  (спроектированы) 

– Остальные добавляются по готовности

# Стратегии интеграции 

● Больше объем интеграции — больше сложность 

– Для каждого интерфейса должен быть разработан короткий тест план

● Выбор в зависимости от архитектуры ПО 

● Последовательность имеет значение 

● Можно тестировать нефункциональные характеристики

## Алгоритмы интеграционного тестирования

### Сверху вниз

Интеграционное тестирование __сверху вниз__ (как в лабе) - сначала тестируют только самый верхний управляющий уровень системы, без модулей более низкого уровня. Затем постепенно с более высокоуровневыми модулями интегрируются более низкоуровневые.

__Преимущества:__

- Легко обнаружить неисправности или ошибки в работе системы.
- В первую очередь проверяются важные модули, а лишь потом модули нижнего порядка.
- По сравнению с другими подходами, время на тестирование интеграции очень коротко.

__Недостатки:__

- Если в модули нижнего уровня заложена важная логика, она не может быть протестирована в первую очередь
- Использование «заглушек»становится обязательным на всех последующих проектах.

### Снизу вверх

Интеграционное тестирование __снизу вверх__ (если бы мы сначала в лабе протестировали синус и ln, потом sin, cos, lnб потом все тригонометрические и логарифмические функции и т.д) - подход подразумевает проверку низкоуровневых систем для начала: вместе и по отдельности. Другими словами процесс тестирования начинается с внутреннего уровня и постепенно доходит до наиболее критичных позиций.

__Преимущества:__

- Если определенный модуль перестает функционировать, его ошибка может быть сразу же исправлена.
- Требуется минимальное время на идентификацию и устранение ошибок.

__Недостатки:__

- Общее время проверки всех модулей довольно долгое
- Если ПО содержит много небольших модулей мелкого уровня, которые очень сложны в своей имплементации, то для завершения процесса тестирования может потребоваться больше времени.

### Большой взрыв

Тестирование методом __большого взрыва__ -  созданные и запрограммированные модули и системные компоненты соединены между собой. При объединении эти модули тестируются как единое целое. После проведения юнит-тестов, модули также проверяются вместе, еще до образования целостной программной системы.

__Преимущества:__

- Удобен  при тестировании небольших систем.
- Быстрое нахождение ошибок

__Недостатки:__

- Так как модули завязаны на одной системе, порой очень трудно найти источник дефектов.
- Если в системе используется много модулей, может уйти достаточно времени, чтобы пересмотреть все реализованные функциональности.




# 14. Тестирование системы целиком  - системное тестирование

Системное тестирование программного обеспечения — это тестирование ПО, выполняемое на полной, интегрированной системе, с целью проверки соответствия системы исходным требованиям. Системное тестирование относится к методам тестирования чёрного ящика, и, тем самым, не требует знаний о внутреннем устройстве системы.

Задача: проверка как функциональных и не функциональных требований в системе в целом. 

При этом выявляются дефекты, такие как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т.д. Для минимизации рисков, связанных с особенностями поведения системы в той или иной среде, во время тестирования рекомендуется использовать окружение максимально приближенное к тому, на которое будет установлен продукт после выдачи.

- на базе требований (requirements based)
- на базе случаев использования (use case based)

Включает несколько фаз:

- Системное тестирование — выполняется внутри организации-разработчика
- Альфа- и Бета-тестирование — выполняется пользователем под контролем разработчика
- Приемочное тестирование — выполняется пользователем.

# 15. Тестирование возможностей, стабильности, отказоустойчивости, совместимости

Относится к нефункциональному тестированию.

__Тестирование возможностей__ - минимальная нагрузка, состоящая из корректных и реальных данных, проверка возможностей и функционала системы.

__Тестирование стабильности__ - добавляем нагрузку, данные всё еще корректны. Проверяем как система работает в более-менее реальных условиях

__Тестирование отказоустойчивости__ - пытаемся всё сломать к чертям. Некорректные данные, большая нагрузка, сбои питания, восстановление после отказа и т.д.

__Тестирование совместимости__ - запуск с различными версиями библиотек, на различном окружении. Смотрим как система со всем этим работает.

# 16. Тестирование производительности - CARAT.

CARAT -- подход к нагрузочному тестированию.

_Capacity_ — Нефункциональные возможности (Максимальное количество (пользователей,
записей в БД, файлов, Кб, ГГц), поддерживаемое системой одновременно, не нарушая других
требований производительности
)

_Accuracy_ — Точность -- корректность алгоритмов и результатов.

_Responce Time_ — Время ответа -- время ответа сервиса при разных видах нагрузки.

_Availability_ — Готовность -- способность сервиса обслуживать клиента.

_Throughput_ — Пропускная способность -- количество операций в секунду, которое может поддерживать система.

# 17. Альфа и Бета тестирование. Приемочное тестирование

__Альфа-тестирование__ — имитация реальной работы с системой штатными разработчиками, либо реальная работа с системой потенциальными пользователями/заказчиком.

Альфа-тестирование - проводится небольшим количеством пользователей внутри организации, разработавшей ПО.

– Может проводиться до окончания системного тестирования
– Ранние отзывы пользователей об использовании системы в рабочем окружении

__Бета-тестирование__ — в некоторых случаях выполняется распространение предварительной версии (в случае проприетарного программного обеспечения иногда с ограничениями по функциональности или времени работы) для некоторой большей группы лиц с тем, чтобы убедиться, что продукт содержит достаточно мало ошибок. Иногда бета-тестирование выполняется для того, чтобы получить обратную связь о продукте от его будущих пользователей.

- Могут быть ошибки
- Может быть не реализован весь функционал
- Ранние отзывы для разработчиков
- Превью для пользователей


__Приёмочное тестирование__ - формальный процесс тестирования, который проверяет соответствие системы требованиям и проводится с целью: определения удовлетворяет ли система приемочным критериям; вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.





# 18. Статическое тестирование. Рецензия, технический анализ, сквозной контроль. 

__Рецензирование__ - вид тестирования ПО (включая код), который может проводиться перед динамическим тестированием. Рецензирование может проводиться вручную или с помощью специальных программных средств. 

Преимущества рецензирования: раннее обнаружение и исправление дефектов, улучшение продуктивности разработки, уменьшение времени разработки, уменьшение времени и стоимости тестирования, сокращение стоимости жизненного цикла, уменьшение числа дефектов и улучшение коммуникаций. Во время рецензирования могут быть найдены упущения, например, в требованиях, которые маловероятно найти во время динамического тестирования.

Основная __идея__ рецензирования заключается в систематической (пере)проверке кода с целью найти ошибки, допущенные при его написании.

__Типы рецензирования:__

- Неформальное рецензирование

  - Главные цели: результат при минимуме затрат

  - Отсутствие формального процесса
  
  - Может принимать форму парного программирования или рецензирования дизайна или кода техническим руководителем

  - Результаты могут быть документированы
  
  - Эффективность зависит от экспертов

- Сквозной контроль

  - Главные цели: обучение, достижение понимания, поиск дефектов

  - Может быть в форме сценариев, сухих прогонов, участия членов команды

  - Не ограниченные по времени сессии

  - Наличие секретаря (не автора) необязательно

  - На практике могут варьироваться от неформальных до строго формальных


- Технический анализ 
  
  - Главные цели: обсуждение, принятие решений, оценка альтернатив, нахождение дефектов, решение технических проблем и проверка соответствия требованиям, планам, нормам и стандартам

  - Документированный процесс определения и нахождения дефектов, который включает участников команды, технических экспертов и, возможно, руководство

  - Может проводиться как равноправный анализ без участия руководства
  
  - В идеале проводится обученным модератором (не автором)

  - Предварительная подготовка экспертов
  
  
  
  
  
  
# 19. Статическое тестирование. Инспекции. 

- Главная цель: поиск дефектов

- Проводится обученным модератором

- Обычно сопровождается равноправным исследованием

- Роли определены

- Включает сбор метрик

- Формальный процесс основан на правилах и контрольных списках

- Определены критерии входы и выхода для приемки программного продукта

- Предварительная подготовка перед встречей

- Инспекционный отчет включает список найденных проблем и вопросов

- Формальный процесс отслеживания o Необязательно - процесс улучшения компонентов




# 20. Статическое тестирование. Статический анализ кода.

Цель статического тестирования - нахождение дефектов в коде или моделях ПО. Фактически статический анализ – это исследование ПО с помощью специального инструмента без его запуска, при динамическом тестировании ПО требуется запуск кода. Статический анализ выявляет дефекты, которые сложно найти при динамическом тестировании. 

Преимущества статического анализа:

- Раннее обнаружение дефектов до исполнения тестов

- Раннее предупреждение о подозрительных аспектах в коде или дизайне с помощью вычисления метрик, таких как коэффициент сложности

- Определение дефектов, которые сложно обнаружить с помощью динамического тестирования

- Определение зависимостей и нарушений целостности в моделях ПО, например ссылок

- Улучшение пригодности к сопровождению кода и дизайна

- Предотвращение дефектов путем усвоения уроков, полученных во время разработки




# 21. Выбор тестового покрытия с помощью анализа эквивалентности. Анализ граничных значений. 

__Класс эквивалентности__ - одно или несколько значений ввода, к которым программное обеспечение применяет одинаковую логику.

__Техника анализа эквивалентности__ - техника, при которой разделяется функционал на группы эквивалентных по своему влиянию на систему значений.

<img src='https://sun9-73.userapi.com/yG1XOnNoXG0j4n4TuVEDp-vA_w4bb3u3enJZ2Q/pjm3ENXpsvs.jpg'>






# 22. Выбор тестового покрытия с помощью таблицы решений. 

__Таблица решений__ — способ компактного представления модели со сложной логикой;

В таблицах решений представлен набор условий, одновременное выполнение которых должно привести к определённому действию.

<img src='https://sun9-29.userapi.com/X2Mj1dIxmUAA4Jd8o_Oi3el8P4APe_fdFH8pEQ/qaW7NTQ-wIg.jpg'>






# 23. Выбор тестового покрытия с помощью диаграммы состояний и таблицы переходов. 

__Диаграма состояний__ – метод тестирования «черного ящика», который используется там, где аспект системы может быть описан конечным автоматом.

<img src="https://sun1-19.userapi.com/q_AY9KRMqamTX5p2TzxZOTqtMBEod8nW35JMWQ/CsDYIP6psuI.jpg">


__Таблица переходов:__

<img src="https://sun9-57.userapi.com/impf/p-jf7feegMsAbr2Gd0x6X-2r1ylmD4yLsdEWng/JWT2Q-z68AA.jpg?size=1121x341&quality=96&proxy=1&sign=f2e9f1344cd39281abb5c87fd829b3f5&type=album">



# 24. Выбор тестового покрытия с помощью функционального тестирования. 

<img src="https://sun9-44.userapi.com/impf/xbAytM9ccSnR3dAdR00wtMJYfPCbbETt4gWQhQ/eULY0YsjyDM.jpg?size=974x594&quality=96&proxy=1&sign=f8ae11866fa78fa5d6233ea126d29f36&type=album">



# 25. Библиотека JUnit. Класс junit.framework.Assert. 

В JUnit существует класс Assert, позволяющий использовать методы для сравнения результата теста с ожидаемым значением.


## Основные функции


`assertEquals` -- использует метод `equals()`

`assertFalse`

`assertNotNull`

`assertNull`

`assertNotSame`

`assertSame` -- cравнивает объекты при помощи  `==` 

`assertTrue`


assertEquals не существует для примитивных типов, потому следует следить за тем, чтобы не произошло автобоксинга(например, результат теста int сравнивается с результатом метода sum, который является long)




# 26. Библиотека JUnit. Основные аннотации для исполнения тестов. 

### Основние аннотации

`@Test`

`@BeforeEach`

`@AfterEach`

`@BeforeAll`

`@AfterAll`

`@Disabled`


# 27. Библиотека JUnit. Дополнительные возможности, запуск с параметрами. 

`@RunWith`  - как запускается тест, класс, указанный в аннотации должен наследоваться от Runner

`@RunWith(Parameterized.class)` -параметризованные тесты

`@Parameters` можно вводить значения данных непосредственно в поля без необходимости использования конструктора

Пример:

```java

@RunWith(Parameterized.class)
public class ParameterizeTest {
    private int valueA;
    private int valueB;
    private int expected;
 
    public ParameterizeTest(int valueA, int valueB, int expected) {
        this.valueA = valueA;
        this.valueB = valueB;
        this.expected = expected;
    }
 
    @Parameterized.Parameters(name = "{index}:sumOf({0}+{1})={2}")
    public static Iterable<Object[]> dataForTest() {
        return Arrays.asList(new Object[][]{
                {1, 1, 2},
                {2, 6, 8},
                {18, 2, 20},
                {13, 15, 28},
                {1, 5, 6}
        });
    }
 
    @Test
    public void paramTest() {
        assertEquals(expected, new Calculator().getSum(valueA,valueB));
    }
}

```




# 28. Анализ эквивалентности с использованием JUnit. 



# 29. Тестирование алгоритмов с использованием JUnit. 



# 30. Модульное тестирование доменной модели с использованием JUnit. 


