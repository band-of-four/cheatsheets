# Лекция 2

## Дезинтеграция полупроводниковой индустрии

После того, как создан проект СнК:

1. он может быть выполнен в виде специализированной микросхемы, которая заточена под определенную функцию (кодеки для аудио/видео), 
под какую-то определенную задачу _ASIC_ - application sprcific integrated circuit 

_плюсы_: тут тактовые частоты могут быть порядка ГГц, компактное решение, 

_минусы_: дорогостоящий вариант

2. FPGA 

_плюсы:_ гибко, недорого и можно перепрограммировать, 

_минусы:_ но низкие частоты (МГц), при конфигурировании занимается много места - не компактн


3. структурированный ASIC - проект на ПЛИС, который потом представляется в виде чипа, 
(чип от ПЛИС, где убрали конфигурационную логику, при этом запрограммировав "намертво" конфигурационные ячейки)

_плюсы_: частота больше, чем на ПЛИС

## Расходы на производство микросхем

Дорого)

1-aя лекция, слайды в конце

## Основные понятия

__HLS__ (High Level Synthesis) -- технология высокоуровневого синтеза

__Синтез__ (трансляция) -- сборка целого из составных частей. Может быть на разных уровнях абстракции. Сборка из менее низкоуровневых частей более детализированное 

__Уровень__ (уровень абстракции) -- уровень представления системы с опусканием неважных с точки зрения контекста рассмотрения деталей

## Что HLS автоматизирует?

1. Проведения анализа проекта и извлечение операций, которые могут выполняться параллельно, и выполнение планирование процесса

2. Генерация интерфейсов и контроллеров ввода-вывода

3. Создание устройств управления вычислительным процессом

4. Оптимизация проекта по времени, площади и энергопотреблению в зависимости от того, что важнее пользователю

## Формализация процесса проектирования

__Формализация__ - это процесс, результатом которого является представление информации об объекте в форме, доступной для хранения, передачи и обработки другими объектами ( человеком, техническими средствами). Другми словами, формализация -- это придание формы некому результату, будь то схема или какое-то описание.

В основе формализации лежит _язык_. Например, язык программирования, который транслирует написанное в ассембер

Для того, чтобы возможно было формализовать что-либо необходим язык -- однозначные правила для транчтирования на более высоком уровне абстракции

_Цели формализации_ -- автоматизация процесса проектирования и увеличение доли компонентов повторного использования

__Примеры:__

<img src="https://sun9-36.userapi.com/impf/RiBy-k4AtWLG5_T3kf5GEkhls4maRUui2ew7_w/4bSbIcXrWkA.jpg?size=1136x749&quality=96&proxy=1&sign=7a41425e611f4660085227c3b72e0b2a&type=album">

## Преимущества синтазе из С/С++

1. Может быть использован как для ПО, тиак и для аппаратного обеспечения. Т.е. на первых этапах нет разграничения между ПО и апаратным обеспечением, оно происходит на последуующих этапах, не фиксируя на начальных этапах как именно будет использоваться код в дальнейшем

2. Связь с аппаратурой за счет указателей, типам данных. Можно проводить напрямую манипуляции с памятью, что дает большую гибкость

3. Накоплена большая кодовая база в области ЦОС (различные ускорители для обработки аудио, видео, которые _уже_ написаны на С/С++).

4. Понятен для специалистов из разных предметных областей (в том числе даже для матиматиков, физиков, которые напрямую не связаны с разработкой)

## Операции, выполняемые в процессе синтеза

1. Scheduling -- Планирование вычислительного процесса. Распределение операций по тактам. (асинхроные решения стараются не делать, потому что возникает проблема "взрыва пространства состояний", когда много параллельных узлов асинхронно взаимодействуют и сочетание различных событий становится неконтролируемым, поэтому всегда происходит переход к синхронному дизайну, а планирование привязывается к единому синхро-сигналу, кроме того в асинхр. существует проблема гонок)

2. Binding -- Определение ресурсов, с помощью которых можно выполнить операции.

3. Control logic extraction -- Извлечение логики управления. Создание управляющего автомата.

## Трансляция ресурсов

- Каждый функциональный блок описывается в виде функций (т.е элемент синтеза -- это функциия, которая будет сделана в виде отдельного ip-ядра, аппаратного блока)

- Агументы функции -- I/O порты 

- Переменные и массивы транслируются в элементы памяти (регистровую или блочную) 

- Циклы транслируются в однотактовые, многотактовые (по умолчанию) или конвейерные вычислительные блоки

## Конструкции C/C++, которые нельзя синтезировать в современных САПР

- Системные вызовы 

- Динамическое выделение памяти -- нужно всегда знать сколько памяти используется, для того, чтобы определить количество требуемых ресурсов

- Приведение указателей к типу void * -- также непонятно количество занимаемого в памяти места

- Рекурсивные функции -- тоже невозможно понять, как много места требуется для них выделить

## Временные характеристики

- __Latency__ - время между подачей входных данных и получением результата

- __II__ (Iteration interval или Initiation Interval) - минимальное время между посылками новых порций входных данных

Времена измеряются в тактах сигнала синхронизации!

## Оптимизации циклов

1. Развертка циклов (unrolling) -- Если следующая итерация не зависит от предыдущей, то можно развернуть цикл и сделать действия параллельно. Развертка может происходить с разными факторами - сколько итераций будут считаться параллельно

2. Слияние циклов (loops merging) -- Если есть несколько циклов и результаты обоих цикла не зависимы друг от друга, то можно совместить циклы и посчитать все параллельно 

3. Конвейеризация циклов (pipelining) -- Объединение стадий в конвейер -- совмещение нескольких групп операций, которые друг от друга не зависят

## Интерфейсы. Допустимые типы аргументов

__Допустимые типы аргументов:__

- Число (int data)

- Массив (int data[N]) и структуры данных

- Указатель (int * data)

__Возможные интерфейсы:__

- Без логики управления (непосредственная передача значения, когда один блок выставляет значение, а другой -- читает, при этом известно когда стоит читать данные, а когда они не поменялись)

- Интерфейс с протоком рукопожатия (handshake, с данными передается сигнал о том, можно ли считывать) 

-Интерфейс памяти

- Интерфейс очереди

- Стандартизированный интерфейс коммуникационной шины (AXI, Wishbone и др.)

## Отображение аргументов на входные порты

При передачи _обычного числа_: либо совсем без логики управления, либо с какой-то минимальной логикой управления (типа рукопожатия)

Передача _массива_: может быть синтезирован в логику с рукопожатием, в логику с адресом (т.е блок памяти) и интерфейс очереди (нет адреса, блок считывает данные, если очередь не пуста)

Передача _указателя_: может быть синтезирован в логику с рукопожатием, доступ по очереди

<img src="https://sun9-76.userapi.com/impf/DM7Bm_ahhh_CN951DW4uJDuJ_cgAYHW3WiY1ug/wWktcu_yUQM.jpg?size=1102x539&quality=96&proxy=1&sign=8d1a2bd352dba450818c164549affbed&type=album">

## Отображение аргументов на выходные порты

<img src="https://sun9-23.userapi.com/impf/mpwFlmZ6Glolu_gUfK6c54siY8_O5m1ODejFfQ/tChDC9GrPno.jpg?size=1103x518&quality=96&proxy=1&sign=fc5a784396c30cefac2593401f5c0f39&type=album">

## Оптимизация массивов. 

### Склеивание массивов

#### Горизонтальное отображение 

Последовательное расположение одного массива за другим. Делается один отдельный лок в памяти, куда кладуться все массивы

_Плюс:_ Упрощает доступ к элементам массива

_Минус_: увеличивает количество необходимых слов памяти.  

<img src="https://sun9-45.userapi.com/impf/_Xm8_6EA7bd5st7kMsOEfHKlLA38wFL6XLauDA/uwhymmxlNXI.jpg?size=1076x321&quality=96&proxy=1&sign=f171b6046caba6fea872356a45deb363&type=album">

#### Вертикальное отображение

В результирующем массиве младшие биты занимают элементы второго массива, старшие -- биты первого массива. Таким обрахом нулевой элемент результирующего массива - одно большое слово

_Плюс:_ меньше слов блочной памяти

_Минус_: больше разрядность слова. Для доступа надо считать слово, раздеить его на элементы массивов

<img src="https://sun9-58.userapi.com/impf/YAGHPx4zoIC-8FkEO20YJNhAW_C1afqU3mW7zg/VsJ2nMrnzkQ.jpg?size=984x296&quality=96&proxy=1&sign=e88555b34eebf1bc7e6f52ee5669dd8a&type=album">

### Переупорядочивание содердимого

Можно переупорядовачить разными способами в зависимости от необходимости и поставленой задачи (нарпимер, для построчной обработки картинки одним способом): блочное переупорядочивание, цикличное и полное (весь массив в одном слове)

<img src="https://sun9-70.userapi.com/impf/YJmeTbjY_HSlvULWmTk8eX1qja6VvHdMAb_OMw/t-2Icr9foig.jpg?size=1035x392&quality=96&proxy=1&sign=04cb7c959bed34f8c794282ba7e8bc8f&type=album">



# Лекция 3

## Ситуации нарушения функционирования


• Отказ - событие, заключающееся в нарушении работоспособного
состояния объекта.

  - явный/скрытый отказ
  
  - перемежающийся отказ
  
  - деградационный отказ

  - и др.

• Сбой - Самоустраняющийся отказ или однократный отказ,
устраняемый незначительным вмешательством оператора.

## Причины отказов

1. Ошибки проектирования

  • Ошибки спецификации
  
  • Ошибка в выборе проектных решений
  
  (например, сделать сенсорные экраны, когда люди работают в перчатках, или когда это система должна работать в качку на морском судне)
 

2. Ошибки реализации

  • Ошибки технологии производства

  • Ошибки
кодирования/программирования

  • Инструментальная ошибка (работа
компилятора, RTL-синтезатора и др.)


3. Условия эксплуатации

  • Приобретаемые ошибки (старение, воздействие радиации и др.)

  • Ошибки внешних воздействий
(форматы данных,
непрогнозируемая
последовательность стимулов и др.)

  (например, устройство около дверного проема и вокруг двеного проема накладывается кабель и кольцо кабеля создает магнитное поле, которое не лучшим обрахом влияет на окружающую технику)
  
=>

  1. Невычислительные отказы
    
  - Отказы элементной базы
  
  2. Вычислительные отказы
    
  - Нарушение алгоритмов функционирования системы

  Пояснение: мы видим только вычислительные отказы, но в основе них можгут быть как вычислительные, так и невычислительные отказы

## Верификация, валидация и тестирование

__Верификация__ – проверка соответствия параметров
функционирования системы требованиям спецификации.

__Валидация__ – подтверждение того, что продукт соответствует
требованиям эксплуатации.

__Тестирование__ – метод исследования системы посредством
помещения её в различные ситуации и наблюдения за
изменением её характеристик.


## Жизненный цикл СнК

<img src="https://sun9-69.userapi.com/impf/EhdNEPpocQ-dZ6oTRBFRiQdYdJZPN-zNWrgBWQ/8KnLIGFQkmM.jpg?size=879x205&quality=96&proxy=1&sign=e6fd48c03e58789c7143c6e12a691108&type=album">

## Формальный и динамические методы проведения испытаний.

Все методы с прошлой картинки - динамические

### Формальные (статические) методы -- 

1. проверка системы на моделях (конечные автоматы, сети, взаимодействия автоматов друг с другом). 

Проверяется живучесть (при любых обстаятельствах система способна функционировать), 

безопасность (она не навредит никому в процессе функционирования)

и достижимость (в процессе работы система достигает определенные состояния, которые заявлены в спецификации. И к тому же система не избытычна)

2. доказательство теорем

метод логического вывода или доказательство непротиворечивости утвержений в терминах каких-то утверждкний (предикатов, каких-то логических элементов, булевые выражения)

3. проверка эквивалентности

если невозможно описать систему какой-то моделью, то ее можно попробовать преобразовать одну систему к эквивалентной ей (с последующем доказательствои эквивалентности этих систем)

4. статический анализ кода

### Динамические методы верификации

1. направленное тестирование - пишешь тест, проверяешь

2. тесты с генерацией случайных воздействий 

вместо проверки всех возможных 64-битных чисел проверяются рандомные сгенерированные. Не доказывает отсутствие ошибок, а гарантирует низкую вероятность их появления

3. провека формальных свойств

использование тех моделей, что были сделаны на этапе статического анализа и перенести их на этап симуляции


## Варианты симуляции 

### Базовые:

• SIL (software in the loop) – тестируем программную модель аппаратуры. Окружение либо моделируем, либо берем реальное.

• HIL (hardware in the loop) – тестируется реальная аппаратура. Внешнее окружение задается моделью.

### Частные:

• MIL (model in the loop) – объектом тестирования является модель.

• PIL (processor in the loop) – объектом тестирования является реальный процессор.

## Инфраструктура тестирования

UVM (Universal Verification Methodology) – это технология повторного использования тестового окружения, а не технология/методология тестирования/верификации

другими словами - это методы создания тестового окружения, которые позволяют повторно испоользовать части этого окружения

набор библиотек (фреймворк) при помощи которого можно создать тестовое окружение с возможностью дальнейшей передачи для повторного использования

как правило, такие тесты поставляются поставщиком вместе с ip-ядрами, что он поставляет

Пояснения к картинке:

Основные блоки, из которых состоит тестовое окружение: 

DUT (design under test - блок, который проверяется), у него есть I/O порты, которые подключаются к окружению для верификации в котором есть несколько компонентов (мастер агентов - формирует воздействие и слейв агентов - принимает и отвечает, формирует ответное воздействие. Эти агенты - это модели  др. блоков с кот. связан тест и к которому он будет подключен). 

У них есть какая-то базовая общая шина, к которой подключаются драйверы и мониторы агентов. 

Монитор - собирает информацию по данным и может написать соответствующие блоки анализов и визуализировать/как-то обработать их. 

Драйвер используется для того, чтобы описать взаимодействие по данным на уровне интерфейса, который работает в DUT (на низком уровне). Организует подключение к аппаратуре и преобразует высокоуровневую посылку от Sequenser'а в последовательность сигналов для передачи

Sequenser -- воздействие на более высоком уровне (на уровне транзакций)

Кроме того, есть блоки, которые анализирует коммуникационную инфраструктуру (bus monitor chacks conertage), который анализирует обмен между всеми блоками

И как раз весь этот verification component environment и является продуктом, который разрабатывают для всяких ядер и продают

<img src="https://sun9-61.userapi.com/impf/qrs3C0JbHMQecw5N3K_cQIbd-xVfofX40xDlfw/OOx9YI1m0W0.jpg?size=489x417&quality=96&proxy=1&sign=2b4afe2245074c8d26a8816595c86019&type=album">


## Доля пропущенных ошибок перед началом натурных испытаний

<src img="https://sun9-23.userapi.com/impf/qRRZN-w4F-lUcLgw2V9PE_jfxwYQ9ShyCoDuqw/zaSVXv_4QqM.jpg?size=862x445&quality=96&proxy=1&sign=b74ce8d43e87bf9da24e71a80f92f89d&type=album">
  
## Верификация СнК на этапе натурных испытаний

### Преимущества

• Система функционирует в реальном времени

• Система работает в реальных, либо максимально приближенным к реальным условиям

### Особенности

• Возможно наблюдать только за ограниченным количеством элементов системы

• Необходимо создавать специальные вычислительные средства для наблюдения, которые являются частью самой системы

• Один тест ни о чем не говорит. Необходимо проводить множественное тестирование.


## Средства натурной верефикации 

### Внешние средства

• Логические анализаторы

• Осциллографы

• Анализаторы спектра

_Преимущества_: Не надо проектировать диагностическую подсистему. Требуется иметь измерительный прибор.

### Встроенные средства

• Встроенные логические анализаторы

• Встроенные средства протоколирования событий

• Мониторы-утверждения

_Преимущества_: Возможно наблюдать за «быстрыми» внутренними сигналами со скоростью работы системы

_Недостаток_: сигналы быстрые, анализаторы медленные, необходимо сохранять данные на внутренней памяти, которые работают быстро, но встроенной памяти на такое не хватит. Встроенная память измеряется мегабайтами, а событий происходит порядка миллиардов. Необходимо как-то сжимать данные.

## Исправление ошибок на этапе эксплуатации

Для этого используются аппаратные патчи. 

В современных процессорах много различных спекуляций над вычислениями и эти спекуляции могут работать некорректно. Часто есть в системах возможность анализировать корректность поведеняи и в случае ошибки переходить на более низкий уровень работы. Вэтом случае замедляется работа (например, не игнорируется использования кэша первого уровня), но зато процессор работает корректно. При этом считается, что такие _кратковременные_ переводы системы на низкий уровень не сильно ухудшают производительность системы в целом. 









# Лекция 4

HW/SW codesign - процесс __совместного__ проектирования электронных программно-аппаратных систем

## Классическая схема

<img src="https://sun9-33.userapi.com/impf/4SHv9He9W0Vls8XUERgEBcGCS8WQIVpRBoJZLQ/P2kzQl52Z7o.jpg?size=272x278&quality=96&proxy=1&sign=7b6ce18c837adb289f7822df98c8e9d5&type=album">

Минусы:

- может получиться избыточная система

- или система, в которой не хватает чего-то

## Кодизайн

<img src="https://sun9-47.userapi.com/impf/WH8z3kyI251FGTvtlop_nCBZR-97S1aEiLjzxQ/h83zsVbLQjM.jpg?size=488x275&quality=96&proxy=1&sign=03639ea7f99d3e58abcfd2a05feec88b&type=album">

Плюсы:

+ корректировка аппаратуры на ранней стадии

+ после выхода аппаратуры сразу готово ПО

В лючшем случае (по проихзводительности):

все вышеперечисленное делается при помощи аппаратных блоков, а алгоритм управления делается на базе программируемых процессоров => 
можно быстро перестраивать работу аппаратуры , при этом она будет работать быстро

### 2 вида кодизайна

_левая картинка_ -- есть спецификация и работа идет параллельно

_правая картинка_ -- здесь происходит проработка высокоуровневой спецификации (получение модели системы на ранних этапах, на языках С/С++ или других), далее, име представление о системе, разделяется лизайн


## Главные цели методологии кодизайна

1. __co__ ordinations - координаия

в проекте должен быть человек, который позволяет обеспечить интеграцию 

все проектные группы (разработчики приложений -> разработчики ОС -> разработчики встроенного ПО -> разработчики интегральных схем -> разработчики аппаратного обеспечения)
должны работать зависимо друг от друга и дожна производиться координация

2. __co__ ncurrency

одновременная работа аппаратных и программных разработчиков (именно взаимосвязанное, а не параллельное (!))

достигатеся при помощи косимуляции и виртуального прототипирования (прототипирования виртуальных компонент)

главная проблема косимуляции -- время (невозмонжо провести косимуляцию, используя реальное время)

виртуальные прототипы для высокоуровнего ПО (например, ядро линукса) упрощены с точки зрения времени и некоторые проблемы нельзя выявить, потому что окружение идеальное или приближено к идеальному

3. __co__ rrectness

верификация на всех этапах проектирования (сквозная)

проверка на каждом уровне и сопоставление результатов 

отслеживание зависимостей (часто какие-то структурне элементы на разных уровнях не связаны друг с другом, но все равно есть структурные элементы, которые можно связать). Это отслеживание зависимостей называется ЭСО (обычно используетс на низком уровне -- схемы, кристаллы)

_Пример:_  уровень схема -> уровень топология 

Отслеживание зависимостей: примитивы, которые можно перенести: вентили <=> транзисторы 

вентили OR, XOR и пр. можно предсавить разными способами, поэтому однозначно перенести схему XOR в топологию нельзя (могут быть разные схемы, например, на D-триггерах или других)

_однозначно все отследить нельзя, так как меняется детализация представления_

_однозначно можно отобразить связи между элементами, т.е. можно тестировать связи на схеме и связи в топологии _ 

4. __co__ mplexity

борьба со сложностью

- должен быть получен __оптимальный__ дизайн

оптимизируемые характеристики:

- скорость 

- энергопотребление

- производительность

