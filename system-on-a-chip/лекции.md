# Лекция 1
## Система на кристалле
СнК — интегральная схема, объединяющая в себе функциональность целой вычислительной системы и включающая полный набор периферийных блоков, необходимых для решения прикладной задачи.  
Под системой на кристалле также понимается определенная технология проектирования вычислительных систем, ключевыми элементами которой являются:
- Методы и средства системного проектирования, ориентированные на создание гетерогенной (аппаратно-программной) вычислительной платформы
- Повторное использование в проекте готовых библиотечных "аппаратных" блоков (IP-компонентов)
- Следование определенному набору стандартов, регламентирующих правила упаковки и вывода на рынок, как всей системы, так и отдельных ее компонент (стандартизация интерфейсов для того, чтобы они одинаково работали в разных системах)

## Системный подход к проектированию
Начинается со спецификации и на каждом шаге система все больше уточняется становясь все менее абстрактной.  
Сначала из спецификации создается абстрактная платформа, а затем эта платформа делится на аппаратные и программные модели. После этого происходит оценка того, насколько мы эффективно разделили эту модель и насколько эффективно они работают вместе и по результатам этой оценки разделение модели может измениться. Полученная абстрактная архитектура будет называться "золотой абстрактной архитектурой".  
После этого происходит написание программного обеспечения, проектирование IP-блоков и их интеграция в единую систему.

## Проектирование на базе компонент
Мы берем готовые программные и аппаратные компоненты и соединяем их в единую систему с помощью некой коммуникационной структуры.  
Акцент смещается с проектирования отдельных вычислительных узлов на проектирование инфраструктуры их взаимодействия.  
Основные проблемы:
- Выбор топологии (как компоненты будут связаны? Звезда, шина, кольцо?)
- Арбитраж доступа к среде передачи (если множество блоков подключены к общей шине, то какому блоку нужно отдавать приоритет?)
- Диспетчеризация процессов (как расположить во времени взаимодействие процессов?)

## Проектирование на базе платформ
Под платформой понимается совокупность готовых компонент, соединенных в систему. Приложение отображается на готовую платформу с зафиксировнной архитектурой.  
Проектирование основано на опыте (некой "истории успеха").  
Примеры - Raspberry Pi, ZynqBerry

## IP-ядро/IP-компонент  
IP-ядрами могут быть:
- IP-библиотеки базового уровня (низкоуровневое представление мультиплексоров, вентилей и т.д.)
- IP-модули памяти
- Интерфейсные модули памяти
- Процессорные IP-ядра
- Аналоговые блоки (например, цифро-аналоговые преобразователи)
- Вычислительные платформы (множество IP-блоков, связанных воедино)

Виды:
- Мягкое IP-ядро — проект, который не привязан к аппаратным особенностям микросхемы или определенной фабрики
- Жесткое IP-ядро — имеет зависимость от аппаратуры

## Модели вычислений

Модель вычислений — это правило организации вычислительного процесса.
- Модели, описывающие поведение отдельных компонентов:
    - Конечные автоматы — система состояний и переходов между этими состояниями.
    - Система взаимодействующих процессов — грубо говоря, множество конечных автоматов, которые взаимодействуют между собой.
    - Сети Петри
- Модели, описывающие взаимодействие компонентов:
    - Сети процессов Кана —  описывает взаимодействие компонентов с помощью бесконечных очередей сообщений
    - Модель дискретных событий — низкоуровневое представление
    - Модель акторов —  очень абстрактное представление архитектуры, разделение системы на компоненты, которые обмениваются между собой данными. Не специфируем поведение компонентов, не специфируем каналы передачи данных, чисто структура

Заложение некоторой формализованной модели вычислений в основу поведения компонентов или всей системы позволит вам обмениваться знаниями с другими разработчиками, расширять систему и в принципе иметь лучшее понимание о том, как ваша система работает.

## Соединение компонентов
### Система на кристалле с шинной архитектурой
В одной системе на кристалле используется много шин, которые соединяют несколько компонентов друг с другом.

### Сети на кристалле (Network on a chip)
В узлах ставятся маршрутизаторы, которые передают пакеты между ядрами. Между маршрутизаторами прокладываются оптические каналы или радиоканалы для увеличения производительности.

# Лекция 2

## Дезинтеграция полупроводниковой индустрии

После того, как создан проект СнК:

1. он может быть выполнен в виде специализированной микросхемы, которая заточена под определенную функцию (кодеки для аудио/видео), 
под какую-то определенную задачу _ASIC_ - application sprcific integrated circuit 

_плюсы_: тут тактовые частоты могут быть порядка ГГц, компактное решение, 

_минусы_: дорогостоящий вариант

2. FPGA 

_плюсы:_ гибко, недорого и можно перепрограммировать, 

_минусы:_ но низкие частоты (МГц), при конфигурировании занимается много места - не компактн


3. структурированный ASIC - проект на ПЛИС, который потом представляется в виде чипа, 
(чип от ПЛИС, где убрали конфигурационную логику, при этом запрограммировав "намертво" конфигурационные ячейки)

_плюсы_: частота больше, чем на ПЛИС

## Расходы на производство микросхем

Дорого)

1-aя лекция, слайды в конце

## Основные понятия

__HLS__ (High Level Synthesis) -- технология высокоуровневого синтеза

__Синтез__ (трансляция) -- сборка целого из составных частей. Может быть на разных уровнях абстракции. Сборка из менее низкоуровневых частей более детализированное 

__Уровень__ (уровень абстракции) -- уровень представления системы с опусканием неважных с точки зрения контекста рассмотрения деталей

## Что HLS автоматизирует?

1. Проведения анализа проекта и извлечение операций, которые могут выполняться параллельно, и выполнение планирование процесса

2. Генерация интерфейсов и контроллеров ввода-вывода

3. Создание устройств управления вычислительным процессом

4. Оптимизация проекта по времени, площади и энергопотреблению в зависимости от того, что важнее пользователю

## Формализация процесса проектирования

__Формализация__ - это процесс, результатом которого является представление информации об объекте в форме, доступной для хранения, передачи и обработки другими объектами ( человеком, техническими средствами). Другми словами, формализация -- это придание формы некому результату, будь то схема или какое-то описание.

В основе формализации лежит _язык_. Например, язык программирования, который транслирует написанное в ассембер

Для того, чтобы возможно было формализовать что-либо необходим язык -- однозначные правила для транчтирования на более высоком уровне абстракции

_Цели формализации_ -- автоматизация процесса проектирования и увеличение доли компонентов повторного использования

__Примеры:__

<img src="https://sun9-36.userapi.com/impf/RiBy-k4AtWLG5_T3kf5GEkhls4maRUui2ew7_w/4bSbIcXrWkA.jpg?size=1136x749&quality=96&proxy=1&sign=7a41425e611f4660085227c3b72e0b2a&type=album">

## Преимущества синтазе из С/С++

1. Может быть использован как для ПО, тиак и для аппаратного обеспечения. Т.е. на первых этапах нет разграничения между ПО и апаратным обеспечением, оно происходит на последуующих этапах, не фиксируя на начальных этапах как именно будет использоваться код в дальнейшем

2. Связь с аппаратурой за счет указателей, типам данных. Можно проводить напрямую манипуляции с памятью, что дает большую гибкость

3. Накоплена большая кодовая база в области ЦОС (различные ускорители для обработки аудио, видео, которые _уже_ написаны на С/С++).

4. Понятен для специалистов из разных предметных областей (в том числе даже для матиматиков, физиков, которые напрямую не связаны с разработкой)

## Операции, выполняемые в процессе синтеза

1. Scheduling -- Планирование вычислительного процесса. Распределение операций по тактам. (асинхроные решения стараются не делать, потому что возникает проблема "взрыва пространства состояний", когда много параллельных узлов асинхронно взаимодействуют и сочетание различных событий становится неконтролируемым, поэтому всегда происходит переход к синхронному дизайну, а планирование привязывается к единому синхро-сигналу, кроме того в асинхр. существует проблема гонок)

2. Binding -- Определение ресурсов, с помощью которых можно выполнить операции.

3. Control logic extraction -- Извлечение логики управления. Создание управляющего автомата.

## Трансляция ресурсов

- Каждый функциональный блок описывается в виде функций (т.е элемент синтеза -- это функциия, которая будет сделана в виде отдельного ip-ядра, аппаратного блока)

- Агументы функции -- I/O порты 

- Переменные и массивы транслируются в элементы памяти (регистровую или блочную) 

- Циклы транслируются в однотактовые, многотактовые (по умолчанию) или конвейерные вычислительные блоки

## Конструкции C/C++, которые нельзя синтезировать в современных САПР

- Системные вызовы 

- Динамическое выделение памяти -- нужно всегда знать сколько памяти используется, для того, чтобы определить количество требуемых ресурсов

- Приведение указателей к типу void * -- также непонятно количество занимаемого в памяти места

- Рекурсивные функции -- тоже невозможно понять, как много места требуется для них выделить

## Временные характеристики

- __Latency__ - время между подачей входных данных и получением результата

- __II__ (Iteration interval или Initiation Interval) - минимальное время между посылками новых порций входных данных

Времена измеряются в тактах сигнала синхронизации!

## Оптимизации циклов

1. Развертка циклов (unrolling) -- Если следующая итерация не зависит от предыдущей, то можно развернуть цикл и сделать действия параллельно. Развертка может происходить с разными факторами - сколько итераций будут считаться параллельно

2. Слияние циклов (loops merging) -- Если есть несколько циклов и результаты обоих цикла не зависимы друг от друга, то можно совместить циклы и посчитать все параллельно 

3. Конвейеризация циклов (pipelining) -- Объединение стадий в конвейер -- совмещение нескольких групп операций, которые друг от друга не зависят

## Интерфейсы. Допустимые типы аргументов

__Допустимые типы аргументов:__

- Число (int data)

- Массив (int data[N]) и структуры данных

- Указатель (int * data)

__Возможные интерфейсы:__

- Без логики управления (непосредственная передача значения, когда один блок выставляет значение, а другой -- читает, при этом известно когда стоит читать данные, а когда они не поменялись)

- Интерфейс с протоком рукопожатия (handshake, с данными передается сигнал о том, можно ли считывать) 

-Интерфейс памяти

- Интерфейс очереди

- Стандартизированный интерфейс коммуникационной шины (AXI, Wishbone и др.)

## Отображение аргументов на входные порты

При передачи _обычного числа_: либо совсем без логики управления, либо с какой-то минимальной логикой управления (типа рукопожатия)

Передача _массива_: может быть синтезирован в логику с рукопожатием, в логику с адресом (т.е блок памяти) и интерфейс очереди (нет адреса, блок считывает данные, если очередь не пуста)

Передача _указателя_: может быть синтезирован в логику с рукопожатием, доступ по очереди

<img src="https://sun9-76.userapi.com/impf/DM7Bm_ahhh_CN951DW4uJDuJ_cgAYHW3WiY1ug/wWktcu_yUQM.jpg?size=1102x539&quality=96&proxy=1&sign=8d1a2bd352dba450818c164549affbed&type=album">

## Отображение аргументов на выходные порты

<img src="https://sun9-23.userapi.com/impf/mpwFlmZ6Glolu_gUfK6c54siY8_O5m1ODejFfQ/tChDC9GrPno.jpg?size=1103x518&quality=96&proxy=1&sign=fc5a784396c30cefac2593401f5c0f39&type=album">

## Оптимизация массивов. 

### Склеивание массивов

#### Горизонтальное отображение 

Последовательное расположение одного массива за другим. Делается один отдельный лок в памяти, куда кладуться все массивы

_Плюс:_ Упрощает доступ к элементам массива

_Минус_: увеличивает количество необходимых слов памяти.  

<img src="https://sun9-45.userapi.com/impf/_Xm8_6EA7bd5st7kMsOEfHKlLA38wFL6XLauDA/uwhymmxlNXI.jpg?size=1076x321&quality=96&proxy=1&sign=f171b6046caba6fea872356a45deb363&type=album">

#### Вертикальное отображение

В результирующем массиве младшие биты занимают элементы второго массива, старшие -- биты первого массива. Таким обрахом нулевой элемент результирующего массива - одно большое слово

_Плюс:_ меньше слов блочной памяти

_Минус_: больше разрядность слова. Для доступа надо считать слово, раздеить его на элементы массивов

<img src="https://sun9-58.userapi.com/impf/YAGHPx4zoIC-8FkEO20YJNhAW_C1afqU3mW7zg/VsJ2nMrnzkQ.jpg?size=984x296&quality=96&proxy=1&sign=e88555b34eebf1bc7e6f52ee5669dd8a&type=album">

### Переупорядочивание содердимого

Можно переупорядовачить разными способами в зависимости от необходимости и поставленой задачи (нарпимер, для построчной обработки картинки одним способом): блочное переупорядочивание, цикличное и полное (весь массив в одном слове)

<img src="https://sun9-70.userapi.com/impf/YJmeTbjY_HSlvULWmTk8eX1qja6VvHdMAb_OMw/t-2Icr9foig.jpg?size=1035x392&quality=96&proxy=1&sign=04cb7c959bed34f8c794282ba7e8bc8f&type=album">



# Лекция 3

## Ситуации нарушения функционирования


• Отказ - событие, заключающееся в нарушении работоспособного
состояния объекта.

  - явный/скрытый отказ
  
  - перемежающийся отказ
  
  - деградационный отказ

  - и др.

• Сбой - Самоустраняющийся отказ или однократный отказ,
устраняемый незначительным вмешательством оператора.

## Причины отказов

1. Ошибки проектирования

  • Ошибки спецификации
  
  • Ошибка в выборе проектных решений
  
  (например, сделать сенсорные экраны, когда люди работают в перчатках, или когда это система должна работать в качку на морском судне)
 

2. Ошибки реализации

  • Ошибки технологии производства

  • Ошибки
кодирования/программирования

  • Инструментальная ошибка (работа
компилятора, RTL-синтезатора и др.)


3. Условия эксплуатации

  • Приобретаемые ошибки (старение, воздействие радиации и др.)

  • Ошибки внешних воздействий
(форматы данных,
непрогнозируемая
последовательность стимулов и др.)

  (например, устройство около дверного проема и вокруг двеного проема накладывается кабель и кольцо кабеля создает магнитное поле, которое не лучшим обрахом влияет на окружающую технику)
  
=>

  1. Невычислительные отказы
    
  - Отказы элементной базы
  
  2. Вычислительные отказы
    
  - Нарушение алгоритмов функционирования системы

  Пояснение: мы видим только вычислительные отказы, но в основе них можгут быть как вычислительные, так и невычислительные отказы

## Верификация, валидация и тестирование

__Верификация__ – проверка соответствия параметров
функционирования системы требованиям спецификации.

__Валидация__ – подтверждение того, что продукт соответствует
требованиям эксплуатации.

__Тестирование__ – метод исследования системы посредством
помещения её в различные ситуации и наблюдения за
изменением её характеристик.


## Жизненный цикл СнК

<img src="https://sun9-69.userapi.com/impf/EhdNEPpocQ-dZ6oTRBFRiQdYdJZPN-zNWrgBWQ/8KnLIGFQkmM.jpg?size=879x205&quality=96&proxy=1&sign=e6fd48c03e58789c7143c6e12a691108&type=album">

## Формальный и динамические методы проведения испытаний.

Все методы с прошлой картинки - динамические

### Формальные (статические) методы -- 

1. проверка системы на моделях (конечные автоматы, сети, взаимодействия автоматов друг с другом). 

Проверяется живучесть (при любых обстаятельствах система способна функционировать), 

безопасность (она не навредит никому в процессе функционирования)

и достижимость (в процессе работы система достигает определенные состояния, которые заявлены в спецификации. И к тому же система не избытычна)

2. доказательство теорем

метод логического вывода или доказательство непротиворечивости утвержений в терминах каких-то утверждкний (предикатов, каких-то логических элементов, булевые выражения)

3. проверка эквивалентности

если невозможно описать систему какой-то моделью, то ее можно попробовать преобразовать одну систему к эквивалентной ей (с последующем доказательствои эквивалентности этих систем)

4. статический анализ кода

### Динамические методы верификации

1. направленное тестирование - пишешь тест, проверяешь

2. тесты с генерацией случайных воздействий 

вместо проверки всех возможных 64-битных чисел проверяются рандомные сгенерированные. Не доказывает отсутствие ошибок, а гарантирует низкую вероятность их появления

3. провека формальных свойств

использование тех моделей, что были сделаны на этапе статического анализа и перенести их на этап симуляции


## Варианты симуляции 

### Базовые:

• SIL (software in the loop) – тестируем программную модель аппаратуры. Окружение либо моделируем, либо берем реальное.

• HIL (hardware in the loop) – тестируется реальная аппаратура. Внешнее окружение задается моделью.

### Частные:

• MIL (model in the loop) – объектом тестирования является модель.

• PIL (processor in the loop) – объектом тестирования является реальный процессор.

## Инфраструктура тестирования

UVM (Universal Verification Methodology) – это технология повторного использования тестового окружения, а не технология/методология тестирования/верификации

другими словами - это методы создания тестового окружения, которые позволяют повторно испоользовать части этого окружения

набор библиотек (фреймворк) при помощи которого можно создать тестовое окружение с возможностью дальнейшей передачи для повторного использования

как правило, такие тесты поставляются поставщиком вместе с ip-ядрами, что он поставляет

Пояснения к картинке:

Основные блоки, из которых состоит тестовое окружение: 

DUT (design under test - блок, который проверяется), у него есть I/O порты, которые подключаются к окружению для верификации в котором есть несколько компонентов (мастер агентов - формирует воздействие и слейв агентов - принимает и отвечает, формирует ответное воздействие. Эти агенты - это модели  др. блоков с кот. связан тест и к которому он будет подключен). 

У них есть какая-то базовая общая шина, к которой подключаются драйверы и мониторы агентов. 

Монитор - собирает информацию по данным и может написать соответствующие блоки анализов и визуализировать/как-то обработать их. 

Драйвер используется для того, чтобы описать взаимодействие по данным на уровне интерфейса, который работает в DUT (на низком уровне). Организует подключение к аппаратуре и преобразует высокоуровневую посылку от Sequenser'а в последовательность сигналов для передачи

Sequenser -- воздействие на более высоком уровне (на уровне транзакций)

Кроме того, есть блоки, которые анализирует коммуникационную инфраструктуру (bus monitor chacks conertage), который анализирует обмен между всеми блоками

И как раз весь этот verification component environment и является продуктом, который разрабатывают для всяких ядер и продают

<img src="https://sun9-61.userapi.com/impf/qrs3C0JbHMQecw5N3K_cQIbd-xVfofX40xDlfw/OOx9YI1m0W0.jpg?size=489x417&quality=96&proxy=1&sign=2b4afe2245074c8d26a8816595c86019&type=album">


## Доля пропущенных ошибок перед началом натурных испытаний

<src img="https://sun9-23.userapi.com/impf/qRRZN-w4F-lUcLgw2V9PE_jfxwYQ9ShyCoDuqw/zaSVXv_4QqM.jpg?size=862x445&quality=96&proxy=1&sign=b74ce8d43e87bf9da24e71a80f92f89d&type=album">
  
## Верификация СнК на этапе натурных испытаний

### Преимущества

• Система функционирует в реальном времени

• Система работает в реальных, либо максимально приближенным к реальным условиям

### Особенности

• Возможно наблюдать только за ограниченным количеством элементов системы

• Необходимо создавать специальные вычислительные средства для наблюдения, которые являются частью самой системы

• Один тест ни о чем не говорит. Необходимо проводить множественное тестирование.


## Средства натурной верефикации 

### Внешние средства

• Логические анализаторы

• Осциллографы

• Анализаторы спектра

_Преимущества_: Не надо проектировать диагностическую подсистему. Требуется иметь измерительный прибор.

### Встроенные средства

• Встроенные логические анализаторы

• Встроенные средства протоколирования событий

• Мониторы-утверждения

_Преимущества_: Возможно наблюдать за «быстрыми» внутренними сигналами со скоростью работы системы

_Недостаток_: сигналы быстрые, анализаторы медленные, необходимо сохранять данные на внутренней памяти, которые работают быстро, но встроенной памяти на такое не хватит. Встроенная память измеряется мегабайтами, а событий происходит порядка миллиардов. Необходимо как-то сжимать данные.

## Исправление ошибок на этапе эксплуатации

Для этого используются аппаратные патчи. 

В современных процессорах много различных спекуляций над вычислениями и эти спекуляции могут работать некорректно. Часто есть в системах возможность анализировать корректность поведеняи и в случае ошибки переходить на более низкий уровень работы. Вэтом случае замедляется работа (например, не игнорируется использования кэша первого уровня), но зато процессор работает корректно. При этом считается, что такие _кратковременные_ переводы системы на низкий уровень не сильно ухудшают производительность системы в целом. 









# Лекция 4

HW/SW codesign - процесс __совместного__ проектирования электронных программно-аппаратных систем

## Классическая схема

<img src="https://sun9-33.userapi.com/impf/4SHv9He9W0Vls8XUERgEBcGCS8WQIVpRBoJZLQ/P2kzQl52Z7o.jpg?size=272x278&quality=96&proxy=1&sign=7b6ce18c837adb289f7822df98c8e9d5&type=album">

Минусы:

- может получиться избыточная система

- или система, в которой не хватает чего-то

## Кодизайн

<img src="https://sun9-47.userapi.com/impf/WH8z3kyI251FGTvtlop_nCBZR-97S1aEiLjzxQ/h83zsVbLQjM.jpg?size=488x275&quality=96&proxy=1&sign=03639ea7f99d3e58abcfd2a05feec88b&type=album">

Плюсы:

+ корректировка аппаратуры на ранней стадии

+ после выхода аппаратуры сразу готово ПО

В лючшем случае (по проихзводительности):

все вышеперечисленное делается при помощи аппаратных блоков, а алгоритм управления делается на базе программируемых процессоров => 
можно быстро перестраивать работу аппаратуры , при этом она будет работать быстро

### 2 вида кодизайна

_левая картинка_ -- есть спецификация и работа идет параллельно

_правая картинка_ -- здесь происходит проработка высокоуровневой спецификации (получение модели системы на ранних этапах, на языках С/С++ или других), далее, име представление о системе, разделяется лизайн


## Главные цели методологии кодизайна

1. __co__ ordinations - координаия

в проекте должен быть человек, который позволяет обеспечить интеграцию 

все проектные группы (разработчики приложений -> разработчики ОС -> разработчики встроенного ПО -> разработчики интегральных схем -> разработчики аппаратного обеспечения)
должны работать зависимо друг от друга и дожна производиться координация

2. __co__ ncurrency

одновременная работа аппаратных и программных разработчиков (именно взаимосвязанное, а не параллельное (!))

достигатеся при помощи косимуляции и виртуального прототипирования (прототипирования виртуальных компонент)

главная проблема косимуляции -- время (невозмонжо провести косимуляцию, используя реальное время)

виртуальные прототипы для высокоуровнего ПО (например, ядро линукса) упрощены с точки зрения времени и некоторые проблемы нельзя выявить, потому что окружение идеальное или приближено к идеальному

3. __co__ rrectness

верификация на всех этапах проектирования (сквозная)

проверка на каждом уровне и сопоставление результатов 

отслеживание зависимостей (часто какие-то структурне элементы на разных уровнях не связаны друг с другом, но все равно есть структурные элементы, которые можно связать). Это отслеживание зависимостей называется ЭСО (обычно используетс на низком уровне -- схемы, кристаллы)

_Пример:_  уровень схема -> уровень топология 

Отслеживание зависимостей: примитивы, которые можно перенести: вентили <=> транзисторы 

вентили OR, XOR и пр. можно предсавить разными способами, поэтому однозначно перенести схему XOR в топологию нельзя (могут быть разные схемы, например, на D-триггерах или других)

_однозначно все отследить нельзя, так как меняется детализация представления_

_однозначно можно отобразить связи между элементами, т.е. можно тестировать связи на схеме и связи в топологии _ 

4. __co__ mplexity

борьба со сложностью

- должен быть получен __оптимальный__ дизайн

оптимизируемые характеристики:

- скорость 

- энергопотребление

- производительность

## Об истории

### Первое поколение (до 1995г)

синтез аппаратуры из языков программирования (из сиподобной функциональной спецификации)

синтез из алгоритмического описания (применяется до сих пор, его в лабах и применяем)

процессор <-> общая шина <-> ускоритель (microblaze)

Есть 2 отправных точки для синтеза:

1. полностью аппаратная реализация -> перенос в программную

2. полностью программная реализация -> перенос в аппаратную

Вся работа происходит в одном потоке => лабо процессор, либо ускоритель

характеризуелься: _однопроцессорность, однопоточность_

### Второе поколение (до 2004г)

Связано с распространением _многопоточного программирования и мультипроцессорности_

Появляются инструменты для косимуляции => одновременная разработка каких-либо драйверов и аппаратура совместно.

(процессор представляется в виде виртуальной можели и связывается аппаратурой)

### Третье поколение (до 2015г)

Платформы становятся гетерогенными, включают различные виды вычислителей: RISC, DSP и др, с различными принципами организации вычислений

- появляется сложность подбора платформы косимуляции

- появляются сети на кристалле (NOC)

- появляется возможность взаимодействия между реальными аппаратными блоками

_Актуальная задача_: полностью автоматизированный межуровневый синтез

### Четвертое поколение (настоящее время)

Характеризуется появлением _киберфизических систем_

=> появилась необходимость взаимодействия с внешним миром (аналого-цифровые преобразования, интеграция цифровых блоков в аналоговую часть)

=> необходимо синтезировать не только цифровые СНК, но и включать аналоговые части 

=> интеграция беспроводных передатчиков внутрь кристалла

=> перемещение дизайна в runtime фазу (для адаптивности, раконфигурирования и обучения системы)

## Задачи синтеза 

1. Allocation - выбор ресурсов

2. Binding - связывание функциональности

3. Scheduling - диспетчеризация ресурсов между процессами (планирование)

разделение _mapping_ = Binding + Scheduling

отображение _partitioning = Allocation + Binding

## Задача разделения

<img src="https://sun9-49.userapi.com/impf/X-aLo8eVcoO0RLqbjhaIEUbR31yLjxsiPQwkHw/cZ1fg2Q7m6s.jpg?size=1037x735&quality=96&proxy=1&sign=646014f4c1c5f1f881de729cfd3c8056&type=album">

## Задача целочисленного программирования

<img src="https://sun9-13.userapi.com/impf/ltN6pQ45ei-w58_Iqg63uIhSq1qF7lxhUyCc6g/oxG98-JD0rc.jpg?size=1091x561&quality=96&proxy=1&sign=1552ffdf8d8cd854d82a292cbc393e18&type=album">

## Пример постановки задачи целочисленного программирования

<img src="https://sun9-36.userapi.com/impf/Ez1Ltw0UxNX8iIfsEyME6nRRKeyXcY9l4IrDVQ/YnSTpHUThOU.jpg?size=1062x328&quality=96&proxy=1&sign=4ab7a9e523e341e04aab904dd731a386&type=album">


## Разделение с использованием графа (1)

<img src="https://sun9-50.userapi.com/impf/W6OaQxGyC3XPayYLsp7wOuEEM9weI70OEvYHzA/BLTWfwRikRI.jpg?size=1086x639&quality=96&proxy=1&sign=3822936f0cbff516ab86ac656ddeadbc&type=album">

Решение: если затраты на передачу через MIPS и DSP не велики, то FPGA и ASIC излишни и можно обойтися только MIPS и DSP

<img src="https://sun9-11.userapi.com/impf/cH_ayzh0lv_K0PdK2D900nAfo2IIs0nqsQsaiA/LXDvp10cYLM.jpg?size=1157x803&quality=96&proxy=1&sign=2d8f0d71748f8a139c0925b330049c28&type=album">

## Иерархическая кластеризация (пример)

<img src="https://sun9-7.userapi.com/impf/ARnQlIBtJ9GVic6p3S6RPAiMs43fMvkqYau86w/hTw87vbIO1U.jpg?size=1077x567&quality=96&proxy=1&sign=e1d0c576ebe4ffca5b92ab259cd2044b&type=album">

<img src="https://sun9-36.userapi.com/impf/KZggPm4EVUsjhCKS2wf4UW9Q4_Pe1KD-E3IEwA/re65T1bprHI.jpg?size=1032x634&quality=96&proxy=1&sign=53db6eba115ba504b3296f51d9de2000&type=album">

<img src="https://sun9-53.userapi.com/impf/m_7-D1_Ip0pK1SWVA99anSkS3-1Z8Ivox9gbMg/xRWTk5xTW7k.jpg?size=991x600&quality=96&proxy=1&sign=d91f8fe77e648e01f4aa9f8db17be1ab&type=album">

# Лекция 5

## Model-based design

<img src="https://sun9-6.userapi.com/impf/Sn537AeWx_gAefKTdZAOHOyCdetvEst5sAxL3A/JGI-xYEm65U.jpg?size=1031x722&quality=96&proxy=1&sign=9bfbbf828fa68e6d1007fd21ea4890fd&type=album">

*Модельно-ориентированное проектирование* - декларативное проектирование через автоматическое или автоматизированное управление последовательно
детализируемыми моделями.

Если проще - на каждом этапе проектирования мы фиксируем результат проектирования в виде модели (желательно исполняемой, но не обязательно) и указываем связи между
последовательными моделями. Таким образом, в результате проектирования мы получаем набор связанных друг с другом моделей, и мы можем
на каждом этапе проверить модель на соответствие требованиям. При таком проектировании на каждом шаге модели детализируются, мы двигаемся
от абстрактных моделей к наиболее конкретизированным.

Данный подход является более высокоуровневым чем все рассмотренные ранее (системное проектирование, проектирование на основе готовых компонент итд),
то есть они все представимы через модельно-ориентированное проектирование.

## Model-driven development

Подход к проектированию, основанный на визуализации структуры системы в виде декларативных высокоуровневых моделей, пригодных
для генерации программного кода или описаний аппаратных блоков.

Когда мы говоирм про MDD, мы спускаемся на уровень реализаций. Включает в себя не только генерирование моделей, но и автоматизацию
генераций реализаций из этих моделей. Модели - основные артефакты проектирования.

### Виды моделей

* `Computational Independent Models` - _Не зависящие от организации вычислительного процесса_ - не фиксирует поведение системы,
не привязывает ни к какой платформе, говорит о системе как о элементе взаимодействия с человеком или со средой. К примеру - описания
предметной области, модели использования системы, надежностные модели итд.
* `Platform Independent Models` - _Не зависящие от платформы_ - указывается поведение системы и схем взаимодействия компонентов, но на
очень абстрактном уровне - уровне базовых моделей вычислений. Например - конечный автомат, сети процессов Кана/Петри, потоков данных итд.
* `Platform Specific Models` - _Платформо-зависимые_ - проектные реализации, программный код, описания аппаратных блоков различных уровней
детализаций. Не является конечной реализацией, потому что, например, RTL модель невозможно однозначно синтезировать.
* `Реализация спецификаций` - конкретные реализации, работающий код, схемотехника, низкоуровневые компоненты, которые реализуют элементы
системы
