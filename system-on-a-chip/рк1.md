# Лекция 2

## Дезинтеграция полупроводниковой индустрии

После того, как создан проект СнК:

1. он может быть выполнен в виде специализированной микросхемы, которая заточена под определенную функцию (кодеки для аудио/видео), 
под какую-то определенную задачу _ASIC_ - application sprcific integrated circuit 

_плюсы_: тут тактовые частоты могут быть порядка ГГц, компактное решение, 

_минусы_: дорогостоящий вариант

2. FPGA 

_плюсы:_ гибко, недорого и можно перепрограммировать, 

_минусы:_ но низкие частоты (МГц), при конфигурировании занимается много места - не компактн


3. структурированный ASIC - проект на ПЛИС, который потом представляется в виде чипа, 
(чип от ПЛИС, где убрали конфигурационную логику, при этом запрограммировав "намертво" конфигурационные ячейки)

_плюсы_: частота больше, чем на ПЛИС

## Расходы на производство микросхем

Дорого)

1-aя лекция, слайды в конце

## Основные понятия

__HLS__ (High Level Synthesis) -- технология высокоуровневого синтеза

__Синтез__ (трансляция) -- сборка целого из составных частей. Может быть на разных уровнях абстракции. Сборка из менее низкоуровневых частей более детализированное 

__Уровень__ (уровень абстракции) -- уровень представления системы с опусканием неважных с точки зрения контекста рассмотрения деталей

## Что HLS автоматизирует?

1. Проведения анализа проекта и извлечение операций, которые могут выполняться параллельно, и выполнение планирование процесса

2. Генерация интерфейсов и контроллеров ввода-вывода

3. Создание устройств управления вычислительным процессом

4. Оптимизация проекта по времени, площади и энергопотреблению в зависимости от того, что важнее пользователю

## Формализация процесса проектирования

__Формализация__ - это процесс, результатом которого является представление информации об объекте в форме, доступной для хранения, передачи и обработки другими объектами ( человеком, техническими средствами). Другми словами, формализация -- это придание формы некому результату, будь то схема или какое-то описание.

В основе формализации лежит _язык_. Например, язык программирования, который транслирует написанное в ассембер

Для того, чтобы возможно было формализовать что-либо необходим язык -- однозначные правила для транчтирования на более высоком уровне абстракции

_Цели формализации_ -- автоматизация процесса проектирования и увеличение доли компонентов повторного использования

__Примеры:__

<img src="https://sun9-36.userapi.com/impf/RiBy-k4AtWLG5_T3kf5GEkhls4maRUui2ew7_w/4bSbIcXrWkA.jpg?size=1136x749&quality=96&proxy=1&sign=7a41425e611f4660085227c3b72e0b2a&type=album">

## Преимущества синтазе из С/С++

1. Может быть использован как для ПО, тиак и для аппаратного обеспечения. Т.е. на первых этапах нет разграничения между ПО и апаратным обеспечением, оно происходит на последуующих этапах, не фиксируя на начальных этапах как именно будет использоваться код в дальнейшем

2. Связь с аппаратурой за счет указателей, типам данных. Можно проводить напрямую манипуляции с памятью, что дает большую гибкость

3. Накоплена большая кодовая база в области ЦОС (различные ускорители для обработки аудио, видео, которые _уже_ написаны на С/С++).

4. Понятен для специалистов из разных предметных областей (в том числе даже для матиматиков, физиков, которые напрямую не связаны с разработкой)

## Операции, выполняемые в процессе синтеза

1. Scheduling -- Планирование вычислительного процесса. Распределение операций по тактам. (асинхроные решения стараются не делать, потому что возникает проблема "взрыва пространства состояний", когда много параллельных узлов асинхронно взаимодействуют и сочетание различных событий становится неконтролируемым, поэтому всегда происходит переход к синхронному дизайну, а планирование привязывается к единому синхро-сигналу, кроме того в асинхр. существует проблема гонок)

2. Binding -- Определение ресурсов, с помощью которых можно выполнить операции.

3. Control logic extraction -- Извлечение логики управления. Создание управляющего автомата.

## Трансляция ресурсов

- Каждый функциональный блок описывается в виде функций (т.е элемент синтеза -- это функциия, которая будет сделана в виде отдельного ip-ядра, аппаратного блока)

- Агументы функции -- I/O порты 

- Переменные и массивы транслируются в элементы памяти (регистровую или блочную) 

- Циклы транслируются в однотактовые, многотактовые (по умолчанию) или конвейерные вычислительные блоки

## Конструкции C/C++, которые нельзя синтезировать в современных САПР

- Системные вызовы 

- Динамическое выделение памяти -- нужно всегда знать сколько памяти используется, для того, чтобы определить количество требуемых ресурсов

- Приведение указателей к типу void * -- также непонятно количество занимаемого в памяти места

- Рекурсивные функции -- тоже невозможно понять, как много места требуется для них выделить

## Временные характеристики

- __Latency__ - время между подачей входных данных и получением результата

- __II__ (Iteration interval или Initiation Interval) - минимальное время между посылками новых порций входных данных

Времена измеряются в тактах сигнала синхронизации!

## Оптимизации циклов

1. Развертка циклов (unrolling) -- Если следующая итерация не зависит от предыдущей, то можно развернуть цикл и сделать действия параллельно. Развертка может происходить с разными факторами - сколько итераций будут считаться параллельно

2. Слияние циклов (loops merging) -- Если есть несколько циклов и результаты обоих цикла не зависимы друг от друга, то можно совместить циклы и посчитать все параллельно 

3. Конвейеризация циклов (pipelining) -- Объединение стадий в конвейер -- совмещение нескольких групп операций, которые друг от друга не зависят

## Интерфейсы. Допустимые типы аргументов

__Допустимые типы аргументов:__

- Число (int data)

- Массив (int data[N]) и структуры данных

- Указатель (int * data)

__Возможные интерфейсы:__

- Без логики управления (непосредственная передача значения, когда один блок выставляет значение, а другой -- читает, при этом известно когда стоит читать данные, а когда они не поменялись)

- Интерфейс с протоком рукопожатия (handshake, с данными передается сигнал о том, можно ли считывать) 

-Интерфейс памяти

- Интерфейс очереди

- Стандартизированный интерфейс коммуникационной шины (AXI, Wishbone и др.)

## Отображение аргументов на входные порты

При передачи _обычного числа_: либо совсем без логики управления, либо с какой-то минимальной логикой управления (типа рукопожатия)

Передача _массива_: может быть синтезирован в логику с рукопожатием, в логику с адресом (т.е блок памяти) и интерфейс очереди (нет адреса, блок считывает данные, если очередь не пуста)

Передача _указателя_: может быть синтезирован в логику с рукопожатием, доступ по очереди

<img src="https://sun9-76.userapi.com/impf/DM7Bm_ahhh_CN951DW4uJDuJ_cgAYHW3WiY1ug/wWktcu_yUQM.jpg?size=1102x539&quality=96&proxy=1&sign=8d1a2bd352dba450818c164549affbed&type=album">

## Отображение аргументов на выходные порты

<img src="https://sun9-23.userapi.com/impf/mpwFlmZ6Glolu_gUfK6c54siY8_O5m1ODejFfQ/tChDC9GrPno.jpg?size=1103x518&quality=96&proxy=1&sign=fc5a784396c30cefac2593401f5c0f39&type=album">

## Оптимизация массивов. 

### Склеивание массивов

#### Горизонтальное отображение 

Последовательное расположение одного массива за другим. Делается один отдельный лок в памяти, куда кладуться все массивы

_Плюс:_ Упрощает доступ к элементам массива

_Минус_: увеличивает количество необходимых слов памяти.  

<img src="https://sun9-45.userapi.com/impf/_Xm8_6EA7bd5st7kMsOEfHKlLA38wFL6XLauDA/uwhymmxlNXI.jpg?size=1076x321&quality=96&proxy=1&sign=f171b6046caba6fea872356a45deb363&type=album">

#### Вертикальное отображение

В результирующем массиве младшие биты занимают элементы второго массива, старшие -- биты первого массива. Таким обрахом нулевой элемент результирующего массива - одно большое слово

_Плюс:_ меньше слов блочной памяти

_Минус_: больше разрядность слова. Для доступа надо считать слово, раздеить его на элементы массивов

<img src="https://sun9-58.userapi.com/impf/YAGHPx4zoIC-8FkEO20YJNhAW_C1afqU3mW7zg/VsJ2nMrnzkQ.jpg?size=984x296&quality=96&proxy=1&sign=e88555b34eebf1bc7e6f52ee5669dd8a&type=album">

### Переупорядочивание содердимого

Можно переупорядовачить разными способами в зависимости от необходимости и поставленой задачи (нарпимер, для построчной обработки картинки одним способом): блочное переупорядочивание, цикличное и полное (весь массив в одном слове)

<img src="https://sun9-70.userapi.com/impf/YJmeTbjY_HSlvULWmTk8eX1qja6VvHdMAb_OMw/t-2Icr9foig.jpg?size=1035x392&quality=96&proxy=1&sign=04cb7c959bed34f8c794282ba7e8bc8f&type=album">
